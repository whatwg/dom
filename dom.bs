<pre class='metadata'>
Title: DOM Standard
H1: DOM
Shortname: dom
Status: LS
Group: WHATWG
No Editor: true
!Participate: <a href=https://github.com/whatwg/dom>GitHub whatwg/dom</a> (<a href=https://github.com/whatwg/dom/issues/new>new issue</a>, <a href=https://github.com/whatwg/dom/issues>open issues</a>, <a href=https://www.w3.org/Bugs/Public/buglist.cgi?component=DOM&amp;product=WebAppsWG&amp;resolution=--->legacy open bugs</a>)
!Participate: <a href=https://wiki.whatwg.org/wiki/IRC>IRC: #whatwg on Freenode</a>
!Commits: <a href=https://github.com/whatwg/dom/commits>GitHub whatwg/dom/commits</a>
!Commits: <a href=https://twitter.com/thedomstandard>@thedomstandard</a>
Logo: https://resources.whatwg.org/logo-dom.svg
Abstract: DOM defines a platform-neutral model for events and node trees.
Ignored Terms: EmptyString, Array, Elements, Document
Boilerplate: omit conformance
</pre>

<!--
Bikeshed problems:

"Document" isn't properly defining itself, and the force switch isn't working.
-->

<script src=https://resources.whatwg.org/file-issue.js async></script>

<pre class='anchors'>
urlPrefix: https://encoding.spec.whatwg.org/
    type: dfn;
        text: ascii whitespace
        text: utf-8
        text: encoding
        text: encoding name
        text: big5
        text: euc-jp
        text: euc-kr
        text: gbk
        text: ibm866
        text: iso-2022-jp
        text: iso-8859-10
        text: iso-8859-13
        text: iso-8859-14
        text: iso-8859-15
        text: iso-8859-16
        text: iso-8859-2
        text: iso-8859-3
        text: iso-8859-4
        text: iso-8859-5
        text: iso-8859-6
        text: iso-8859-7
        text: iso-8859-8
        text: iso-8859-8-i
        text: koi8-r
        text: koi8-u
        text: shift_jis
        text: utf-16be
        text: utf-16le
urlPrefix: http://www.w3.org/TR/xml/#NT-
    type: type
        text: Name
        text: Char
urlPrefix: http://www.w3.org/TR/xml-names/#NT-
    type: type
        text: QName
urlPrefix: https://heycam.github.io/webidl/
    type: dfn; urlPrefix: #dfn-
        text: throw
        text: dictionary member
        text: identifier
        text: callback this value
        text: supported property indices
        text: supported property names
        text: unenumerable
        text: code unit
    type: exception
        text: HierarchyRequestError
        text: IndexSizeError
        text: InUseAttributeError
        text: InvalidCharacterError
        text: InvalidNodeTypeError
        text: InvalidStateError
        text: NamespaceError
        text: NotFoundError
        text: NotSupportedError
        text: SyntaxError
        text: WrongDocumentError
        text: DOMException; urlPrefix: #dfn-
    type: interface;
        text: DOMTimeStamp; urlPrefix: #common-
urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn
        urlPrefix: webappapis.html
            text: report the exception
            text: queue a microtask
            text: compound microtask
            text: execute a compound microtask subtask
        urlPrefix: syntax.html
            text: html parser
            text: html parsing; url: #html-parser
        urlPrefix: browsers.html
            text: unit of related similar-origin browsing contexts
            text: origin
            text: effective script origin
            text: origin alias; url: #concept-origin-alias
            text: Unicode serialization of an origin
url: http://www.w3.org/TR/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment
    type: method; text: createContextualFragment(); for: Range;
type: interface
    url: https://dvcs.w3.org/hg/d4e/raw-file/tip/source_respec.htm#keyboard-event-interface
        text: KeyboardEvent
    urlPrefix: https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#interface-
        text: MouseEvent
        text: UIEvent
    url: http://www.w3.org/TR/touch-events/#touchevent-interface
        text: TouchEvent
    url: https://w3c.github.io/webcomponents/spec/shadow/#the-shadowroot-interface
        text: ShadowRoot
</pre>

<pre class='link-defaults'>
spec:html; type:element
    text: title
    text: script
</pre>

<h2 id='goals' class=no-num>
Goals</h2>

This specification standardizes the DOM. It does so as follows:

<ol>
 <li>
  By consolidating <cite>DOM Level 3 Core</cite>
  [[DOMCORE]],
  <cite>Element Traversal</cite>
  [[ELEMENTTRAVERSAL]],
  <cite>Selectors API Level 2</cite>
  [[SELECTORS-API2]], the
  "DOM Event Architecture" and "Basic Event Interfaces" chapters of
  <cite>DOM Level 3 Events</cite>
  [[UI-EVENTS]] (specific type
  of events do not belong in the base specification), and
  <cite>DOM Level 2 Traversal and Range</cite>
  [[DOM-Level-2-Traversal-Range]], and:

  <ul>
   <li>Aligning them with the needs of JavaScript where possible.
   <li>Aligning them with existing implementations.
   <li>Simplifying them as much as possible.
  </ul>

 <li>By moving features from the HTML standard that ought to be part of the DOM
 platform here. [[!HTML]]

 <li>
  By defining a replacement for the "Mutation Events" and
  "Mutation Name Event Types" chapters of <cite>DOM Level 3 Events</cite>
  [[UI-EVENTS]] as the old model
  was problematic.

  Note: The old model is expected to be removed from implementations
  in due course.

 <li>By defining new features that simplify common DOM operations.
</ol>


<h2 id='conformance'>
Conformance</h2>
All diagrams, examples, and notes in this specification are
non-normative, as are all sections explicitly marked non-normative.
Everything else in this specification is normative.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in RFC 2119.
For readability, these words do not appear in all uppercase letters in this
specification. [[!RFC2119]]

Requirements phrased in the imperative as part of algorithms
(such as "strip any leading space characters" or "return false and
terminate these steps") are to be interpreted with the meaning of the
key word ("must", "should", "may", etc) used in introducing the
algorithm.

Conformance requirements phrased as algorithms or specific steps
may be implemented in any manner, so long as the end result is
equivalent. (In particular, the algorithms defined in this
specification are intended to be easy to follow, and not intended to
be performant.)

<p id="hardwareLimitations">User agents may impose
implementation-specific limits on otherwise unconstrained inputs,
e.g. to prevent denial of service attacks, to guard against running
out of memory, or to work around platform-specific limitations.

When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can't change the behavior by overriding attributes or methods with custom properties or functions in JavaScript.

Unless otherwise stated, string comparisons are done in a <a>case-sensitive</a> manner.

<h3 id='dependencies'>
Dependencies</h3>

The IDL fragments in this specification must be interpreted as
required for conforming IDL fragments, as described in the Web IDL
specification. [[!WEBIDL]]

Some of the terms used in this specification are defined in
<cite>Encoding</cite>, <cite>Selectors</cite>, <cite>Web IDL</cite>, <cite>XML</cite>, and
<cite>Namespaces in XML</cite>.
[[!ENCODING]]
[[!SELECTORS4]]
[[!WEBIDL]]
[[!XML]]
[[!XML-NAMES]]

<h3 id='extensibility'>
Extensibility</h3>

Vendor-specific proprietary extensions to this specification are
strongly discouraged. Authors must not use such extensions, as
doing so reduces interoperability and fragments the user base,
allowing only users of specific user agents to access the content in
question.

If vendor-specific extensions are needed, the members should be
prefixed by vendor-specific strings to prevent clashes with future
versions of this specification. Extensions must be defined so that
the use of extensions neither contradicts nor causes the
non-conformance of functionality defined in the specification.
<!-- thanks to QA Framework -->

When vendor-neutral extensions to this specification are needed,
either this specification can be updated accordingly, or an
extension specification can be written that overrides the
requirements in this specification. When someone applying this
specification to their activities decides that they will recognize
the requirements of such an extension specification, it becomes an
<dfn lt="other applicable specifications">applicable
specification</dfn> for the purposes of conformance requirements in
this specification.
<!-- https://www.w3.org/mid/17E341CD-E790-422C-9F9A-69347EE01CEB@iki.fi -->


<h2 id='terminology'>
Terminology</h2>

The term <dfn>context object</dfn> means the object on which the algorithm,
attribute getter, attribute setter, or method being discussed was called. When the
<a>context object</a> is unambiguous, the term can be omitted.

<!-- XXX we should prolly explain that "set attribute X to Y" works even for
readonly attributes when it is language for implementors -->

<h3 id='trees'>
Trees</h3> <!-- Sorry reddit, this is not /r/trees -->

A <dfn id=concept-tree>tree</dfn> is a finite hierarchical tree structure. In
<dfn id=concept-tree-order>tree order</dfn> is preorder, depth-first
traversal of a <a>tree</a>.
<!-- http://en.wikipedia.org/wiki/Tree_traversal#Depth-first_Traversal -->

An object that <dfn for=tree id=concept-tree-participate lt="participate">participates</dfn> in
a <a>tree</a> has a
<dfn for=tree id=concept-tree-parent>parent</dfn>, which is either another object
or null, and an ordered list of zero or more
<dfn for=tree id=concept-tree-child>child</dfn> objects. An object <var>A</var> whose
<a>parent</a> is object <var>B</var> is a
<a>child</a> of <var>B</var>.

The <dfn for=tree id=concept-tree-root>root</dfn> of an object is itself, if its
<a>parent</a> is null, or else it is the
<a for=tree>root</a> of its
<a>parent</a>.

An object <var>A</var> is called a
<dfn for=tree id=concept-tree-descendant>descendant</dfn> of an object
<var>B</var>, if either <var>A</var> is a
<a>child</a> of <var>B</var> or
<var>A</var> is a <a>child</a> of an
object <var>C</var> that is a
<a>descendant</a> of <var>B</var>.

An
<dfn for=tree id=concept-tree-inclusive-descendant>inclusive descendant</dfn> is
an object or one of its
<a>descendants</a>.

An object <var>A</var> is called an
<dfn for=tree id=concept-tree-ancestor>ancestor</dfn> of an object
<var>B</var> if and only if <var>B</var> is a
<a>descendant</a> of
<var>A</var>.

An <dfn for=tree id=concept-tree-inclusive-ancestor>inclusive ancestor</dfn> is
an object or one of its <a>ancestors</a>.

An object <var>A</var> is called a
<dfn for=tree id=concept-tree-sibling>sibling</dfn> of an object
<var>B</var>, if and only if <var>B</var> and <var>A</var>
share the same non-null <a>parent</a>.

An object <var>A</var> is
<dfn for=tree id=concept-tree-preceding>preceding</dfn> an object
<var>B</var> if <var>A</var> and <var>B</var> are in the
same <a>tree</a> and <var>A</var> comes
before <var>B</var> in
<a>tree order</a>.

An object <var>A</var> is
<dfn for=tree id=concept-tree-following>following</dfn> an object
<var>B</var> if <var>A</var> and <var>B</var> are in the
same <a>tree</a> and <var>A</var> comes
after <var>B</var> in
<a>tree order</a>.

The <dfn for=tree id=concept-tree-first-child>first child</dfn> of an object is
its first <a>child</a> or null if it has no
<a>child</a>.

The <dfn for=tree id=concept-tree-last-child>last child</dfn> of an object is
its last <a>child</a> or null if it has no
<a>child</a>.

The <dfn for=tree id=concept-tree-previous-sibling>previous sibling</dfn> of an
object is its first <a>preceding</a>
<a>sibling</a> or null if it has no
<a>preceding</a>
<a>sibling</a>.

The <dfn for=tree id=concept-tree-next-sibling>next sibling</dfn> of an
object is its first <a>following</a>
<a>sibling</a> or null if it has no
<a>following</a>
<a>sibling</a>.

The <dfn for=tree id=concept-tree-index>index</dfn> of an object is its number
of <a>preceding</a>
<a>siblings</a>.


<h3 id='strings'>
Strings</h3>

Comparing two strings in a <dfn>case-sensitive</dfn> manner means comparing them exactly, code point for code point.

Comparing two strings in a <dfn>ASCII case-insensitive</dfn> manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 .. U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 .. U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.

<dfn lt="converted to ascii uppercase">Converting a string to ASCII uppercase</dfn> means replacing all characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z) with the corresponding characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z).

<dfn lt="converted to ascii lowercase">Converting a string to ASCII lowercase</dfn> means replacing all characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z).

A string <var>pattern</var> is a <dfn>prefix match</dfn> for a string
<var>s</var> when <var>pattern</var> is not longer than
<var>s</var> and truncating <var>s</var> to
<var>pattern</var>'s length leaves the two strings as matches of each
other.


<h3 id="ordered sets">Ordered sets</h3>

The <dfn id=concept-ordered-set-parser>ordered set parser</dfn> takes a string
<var>input</var> and then runs these steps:

<ol>
 <li>Let <var>position</var> be a pointer into <var>input</var>,
 initially pointing at the start of the string.

 <li>Let <var>tokens</var> be an ordered set of tokens, initially empty.

 <li><a>Skip ASCII whitespace</a>.

 <li>While <var>position</var> is not past the end of
 <var>input</var>:

  <ol>
   <li><a>Collect a code point sequence</a> of code points that are
   not <a>ASCII whitespace</a>.

   <li>If the collected string is not in <var>tokens</var>, append the
   collected string to <var>tokens</var>.

   <li><a>Skip ASCII whitespace</a>.
  </ol>

 <li>Return <var>tokens</var>.
</ol>

To <dfn>collect a code point sequence</dfn> of
<var>code points</var>, run these steps:

<ol>
 <li>Let <var>input</var> and <var>position</var> be the same
 variables as those of the same name in the algorithm that invoked these
 steps.

 <li>Let <var>result</var> be the empty string.

 <li>While <var>position</var> does not point past the end of
 <var>input</var> and the code point at <var>position</var> is
 one of <var>code points</var>, append that code point to the end
 of <var>result</var> and advance <var>position</var> to the
 next code point in <var>input</var>.

 <li>Return <var>result</var>.
</ol>

To <dfn>skip ASCII whitespace</dfn> means to
<a>collect a code point sequence</a> of
<a>ASCII whitespace</a> and discard the
return value.

The <dfn id=concept-ordered-set-serializer>ordered set serializer</dfn> takes a
<var>set</var> and returns the concatenation of the strings in
<var>set</var>, separated from each other by U+0020.


<h3 id='namespaces'>
Namespaces</h3>

The <dfn>HTML namespace</dfn> is
<code>http://www.w3.org/1999/xhtml</code>.

The <dfn>XML namespace</dfn> is
<code>http://www.w3.org/XML/1998/namespace</code>.

The <dfn>XMLNS namespace</dfn> is
<code>http://www.w3.org/2000/xmlns/</code>.

To <dfn>validate</dfn> a <var>qualifiedName</var>, run these steps:

<ol>
 <li>If <var>qualifiedName</var> does not match the
 <code><a type>Name</a></code> production, <a>throw</a>
 an {{InvalidCharacterError}} exception.

 <li>If <var>qualifiedName</var> does not match the
 <code><a type>QName</a></code> production,
 <a>throw</a> a {{NamespaceError}} exception.
</ol>

To <dfn>validate and extract</dfn> a <var>namespace</var> and <var>qualifiedName</var>,
run these steps:

<ol>
 <li>If <var>namespace</var> is the empty string, set it to null.

 <li><a>Validate</a> <var>qualifiedName</var>. Rethrow any exceptions.

 <li>Let <var>prefix</var> be null.

 <li>Let <var>localName</var> be <var>qualifiedName</var>.

 <li>If <var>qualifiedName</var> contains a "<code>:</code>" (U+003E), then split the
 string on it and set <var>prefix</var> to the part before and <var>localName</var> to
 the part after.

 <li>If <var>prefix</var> is non-null and <var>namespace</var> is null,
 <a>throw</a> a {{NamespaceError}} exception.

 <li>If <var>prefix</var> is "<code>xml</code>" and <var>namespace</var> is
 not the <a>XML namespace</a>, <a>throw</a> a
 {{NamespaceError}} exception.

 <li>If either <var>qualifiedName</var> or <var>prefix</var> is
 "<code>xmlns</code>" and <var>namespace</var> is not the
 <a>XMLNS namespace</a>, <a>throw</a> a
 {{NamespaceError}} exception.

 <li>If <var>namespace</var> is the <a>XMLNS namespace</a> and neither
 <var>qualifiedName</var> nor <var>prefix</var> is "<code>xmlns</code>",
 <a>throw</a> a {{NamespaceError}} exception.

 <li>Return <var>namespace</var>, <var>prefix</var>, <var>localName</var>, and
 <var>qualifiedName</var>.
</ol>



<h2 id='events'>
Events</h2>

<h3 id='introduction-to-dom-events'>
Introduction to "DOM Events"</h3>

Throughout the web platform <a>events</a> are
<a>dispatched</a> to objects to signal an
occurrence, such as network activity or user interaction. These objects
implement the {{EventTarget}} interface and can therefore add
<a>event listeners</a> to observe
<a>events</a>:

<pre class='lang-javascript'>
obj.addEventListener("load", imgFetched)

function imgFetched(ev) {
  // great success
  &hellip;
}
</pre>

<a>Event listeners</a> can be removed
by utilizing the
{{EventTarget/removeEventListener()}}
method, passing the same arguments.

<a>Events</a> are objects too and implement the
{{Event}} interface (or a derived interface). In the example above
<var>ev</var> is the <a>event</a>. It is
passed as argument to
<a>event listener</a>'s <b>callback</b>
(typically a JavaScript Function as shown above).
<a>Event listeners</a> key off the
<a>event</a>'s
{{Event/type}} attribute value
("<code>load</code>" in the above example). The
<a>event</a>'s
{{Event/target}} attribute value returns the
object to which the <a>event</a> was
<a>dispatched</a>
(<var>obj</var> above).

Now while typically <a>events</a> are
<a>dispatched</a> by the user agent as
the result of user interaction or the completion of some task, applications
can <a>dispatch</a>
<a>events</a> themselves, commonly known as
synthetic events:

<pre class='lang-javascript'>
// add an appropriate event listener
obj.addEventListener("cat", function(e) { process(e.detail) })

// create and dispatch the event
var event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
obj.dispatchEvent(event)
</pre>

Apart from signaling, <a>events</a> are
sometimes also used to let an application control what happens next in an
operation. For instance as part of form submission an
<a>event</a> whose
{{Event/type}} attribute value is
"<code>submit</code>" is
<a>dispatched</a>. If this
<a>event</a>'s
{{Event/preventDefault()}} method is
invoked, form submission will be terminated. Applications who wish to make
use of this functionality through <a>events</a>
<a>dispatched</a> by the application
(synthetic events) can make use of the return value of the
{{EventTarget/dispatchEvent()}} method:

<pre class='lang-javascript'>
if(obj.dispatchEvent(event)) {
  // event was not canceled, time for some magic
  &hellip;
}
</pre>

When an <a>event</a> is
<a>dispatched</a> to an object that
<a>participates</a> in a
<a>tree</a> (e.g. an
<a>element</a>), it can reach
<a>event listeners</a> on that object's
<a>ancestors</a> too. First all object's
<a>ancestor</a>
<a>event listeners</a> whose
<b>capture</b> variable is set to true are invoked, in
<a>tree order</a>. Second, object's own
<a>event listeners</a> are invoked. And
finally, and only if <a>event</a>'s
{{Event/bubbles}} attribute value is true,
object's  <a>ancestor</a>
<a>event listeners</a> are invoked again,
but now in reverse <a>tree order</a>.

Lets look at an example on how <a>events</a>
work in a <a>tree</a>:

<pre class='lang-markup'>
&lt;!doctype html>
&lt;html>
 &lt;head>
  &lt;title>Boring example&lt;/title>
 &lt;/head>
 &lt;body>
  &lt;p>Hello &lt;span id=x>world&lt;/span>!&lt;/p>
  &lt;script>
   function test(e) {
     debug(e.target, e.currentTarget, e.eventPhase)
   }
   document.addEventListener("hey", test, true)
   document.body.addEventListener("hey", test)
   var ev = new Event("hey", {bubbles:true})
   document.getElementById("x").dispatchEvent(ev)
  &lt;/script>
 &lt;/body>
&lt;/html>
</pre>

The <code>debug</code> function will be invoked twice. Each time
the <a>events</a>'s
{{Event/target}} attribute value will be the
<code>span</code> <a>element</a>. The
first time {{Event/currentTarget}} attribute's
value will be the <a>document</a>, the second
time the <code>body</code> <a>element</a>.
{{Event/eventPhase}} attribute's value
switches from {{Event/CAPTURING_PHASE}}
to {{Event/BUBBLING_PHASE}}. If an
<a>event listener</a> was registered for
the <code>span</code> <a>element</a>,
{{Event/eventPhase}} attribute's value
would have been {{Event/AT_TARGET}}.


<h3 id='interface-event'>
Interface {{Event}}</h3>

<pre class="idl">
[Constructor(DOMString type, optional EventInit eventInitDict),
 Exposed=(Window,Worker)]
interface Event {
  readonly attribute DOMString type;
  readonly attribute EventTarget? target;
  readonly attribute EventTarget? currentTarget;

  const unsigned short NONE = 0;
  const unsigned short CAPTURING_PHASE = 1;
  const unsigned short AT_TARGET = 2;
  const unsigned short BUBBLING_PHASE = 3;
  readonly attribute unsigned short eventPhase;

  void stopPropagation();
  void stopImmediatePropagation();

  readonly attribute boolean bubbles;
  readonly attribute boolean cancelable;
  void preventDefault();
  readonly attribute boolean defaultPrevented;

  [Unforgeable] readonly attribute boolean isTrusted;
  readonly attribute DOMTimeStamp timeStamp;

  void initEvent(DOMString type, boolean bubbles, boolean cancelable);
};

dictionary EventInit {
  boolean bubbles = false;
  boolean cancelable = false;
};
</pre>

An <dfn id=concept-event>event</dfn> allows for signaling that
something has occurred. E.g. that an image has completed downloading. It is
represented by the {{Event}} interface or an interface that
inherits from the {{Event}} interface.

<dl class=domintro>
 <dt><code><var>event</var> = new <a constructor lt="Event()">Event</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
 <dd>Returns a new <var>event</var> whose
 {{Event/type}} attribute value is set to
 <var>type</var>. The optional {{Event/Event()/eventInitDict!!argument}} argument
 allows for setting the {{Event/bubbles}} and
 {{Event/cancelable}} attributes via object
 members of the same name.

 <dt><code><var>event</var> . {{Event/type}}</code>
 <dd>Returns the type of <var>event</var>, e.g.
 "<code>click</code>", "<code>hashchange</code>", or
 "<code>submit</code>".

 <dt><code><var>event</var> . {{Event/target}}</code>
 <dd>Returns the object <var>event</var> is
 <a>dispatched</a> to.

 <dt><code><var>event</var> . {{Event/currentTarget}}</code>
 <dd>Returns the object whose
 <a>event listener</a>'s <b>callback</b>
 is invoked.

 <dt><code><var>event</var> . {{Event/eventPhase}}</code>
 <dd>Returns the <a>event</a>'s phase, which is
 one of {{Event/NONE}},
 {{Event/CAPTURING_PHASE}},
 {{Event/AT_TARGET}}, and
 {{Event/BUBBLING_PHASE}}.

 <dt><code><var>event</var> . <a method for=Event lt="stopPropagation()">stopPropagation</a>()</code>
 <dd>When <a>dispatched</a> in a
 <a>tree</a>, invoking this method prevents
 <var>event</var> from reaching any other objects than the current.

 <dt><code><var>event</var> . <a method for=Event lt="stopImmediatePropagation()">stopImmediatePropagation</a>()</code>
 <dd>Invoking this method prevents <var>event</var> from reaching
 any <a>event listeners</a> registered
 after the current one and when
 <a>dispatched</a> in a
 <a>tree</a> also prevents
 <var>event</var> from reaching any other objects.

 <dt><code><var>event</var> . {{Event/bubbles}}</code>
 <dd>Returns true if <var>event</var>’s goes through its {{Event/target}} attribute value's <a>ancestors</a> in reverse <a>tree order</a>, and false otherwise.

 <dt><code><var>event</var> . {{Event/cancelable}}</code>
 <dd>Returns true or false depending on how <var>event</var> was
 initialized. Its return value does not always carry meaning, but true can
 indicate that part of the operation during which <var>event</var> was
 <a>dispatched</a>, can be canceled by
 invoking the {{Event/preventDefault()}}
 method.

 <dt><code><var>event</var> . <a method for=Event lt="preventDefault()">preventDefault</a>()</code>
 <dd>If invoked when the
 {{Event/cancelable}} attribute value is true,
 signals to the operation that caused <var>event</var> to be
 <a>dispatched</a> that it needs to be
 canceled.

 <dt><code><var>event</var> . {{Event/defaultPrevented}}</code>
 <dd>Returns true if
 {{Event/preventDefault()}} was invoked
 while the {{Event/cancelable}} attribute
 value is true, and false otherwise.

 <dt><code><var>event</var> . {{Event/isTrusted}}</code>
 <dd>Returns true if <var>event</var> was
 <a>dispatched</a> by the user agent, and
 false otherwise.

 <dt><code><var>event</var> . {{Event/timeStamp}}</code>
 <dd>Returns the creation time of <var>event</var> in the number of
 milliseconds that passed since 00:00:00 UTC on 1 January 1970.

 <!-- initEvent is dead -->
</dl>

The <dfn attribute for=Event>type</dfn> attribute must
return the value it was initialized to. When an
<a>event</a> is created the attribute must be
initialized to the empty string.

The <dfn attribute for=Event>target</dfn> and
<dfn attribute for=Event>currentTarget</dfn>
attributes must return the values they were initialized to. When an
<a>event</a> is created the attributes must be
initialized to null.

The <dfn attribute for=Event>eventPhase</dfn>
attribute must return the value it was initialized to, which must be one of
the following:
<dl>
 <dt><dfn const for=Event>NONE</dfn> (numeric value 0)
 <dd><a>Events</a> not currently
 <a>dispatched</a> are in this phase.
 <dt><dfn const for=Event>CAPTURING_PHASE</dfn> (numeric value 1)
 <dd>When an <a>event</a> is
 <a>dispatched</a> to an object that
 <a>participates</a> in a
 <a>tree</a> it will be in this phase before it
 reaches its {{Event/target}} attribute value.
 <dt><dfn const for=Event>AT_TARGET</dfn> (numeric value 2)
 <dd>When an <a>event</a> is
 <a>dispatched</a> it will be in this
 phase on its {{Event/target}} attribute value.
 <dt><dfn const for=Event>BUBBLING_PHASE</dfn> (numeric value 3)
 <dd>When an <a>event</a> is
 <a>dispatched</a> to an object that
 <a>participates</a> in a
 <a>tree</a> it will be in this phase after it
 reaches its {{Event/target}} attribute value.
</dl>
Initially the attribute must be initialized to
{{Event/NONE}}.

<hr>

Each <a>event</a> has the following associated
flags that are all initially unset:
<ul>
 <li><dfn>stop propagation flag</dfn>
 <li><dfn>stop immediate propagation flag</dfn>
 <li><dfn>canceled flag</dfn>
 <li><dfn>initialized flag</dfn>
 <li><dfn>dispatch flag</dfn>
</ul>

The
<dfn method for=Event>stopPropagation()</dfn>
method must set the <a>stop propagation flag</a>.

The
<dfn method for=Event>stopImmediatePropagation()</dfn>
method must set both the <a>stop propagation flag</a> and
<a>stop immediate propagation flag</a>.

The <dfn attribute for=Event>bubbles</dfn> and
<dfn attribute for=Event>cancelable</dfn> attributes
must return the values they were initialized to.

The
<dfn method for=Event>preventDefault()</dfn>
method must set the <a>canceled flag</a> if the
{{Event/cancelable}} attribute value is true.

The
<dfn attribute for=Event>defaultPrevented</dfn>
attribute must return true if the <a>canceled flag</a> is set and
false otherwise.

<hr>

The <dfn attribute for=Event>isTrusted</dfn> attribute
must return the value it was initialized to. When an
<a>event</a> is created the attribute must be
initialized to false.

The <dfn attribute for=Event>timeStamp</dfn> attribute
must return the value it was initialized to. When an
<a>event</a> is created the attribute must be
initialized to the number of milliseconds that have passed since
00:00:00 UTC on 1 January 1970, ignoring leap seconds.
<!-- leap seconds are ignored by JavaScript too -->

<hr>

To <dfn id=concept-event-initialize>initialize</dfn> an
<var>event</var>, with <var>type</var>,
<var>bubbles</var>, and <var>cancelable</var>, run these steps:

<ol>
 <li>Set the <a>initialized flag</a>.
 <li>Unset the <a>stop propagation flag</a>,
 <a>stop immediate propagation flag</a>, and
 <a>canceled flag</a>.
 <li>Set the {{Event/isTrusted}} attribute
 to false.
 <li>Set the {{Event/target}} attribute to
 null.
 <li>Set the {{Event/type}} attribute to
 <var>type</var>.
 <li>Set the {{Event/bubbles}} attribute to
 <var>bubbles</var>.
 <li>Set the {{Event/cancelable}} attribute
 to <var>cancelable</var>.
</ol>

The
<dfn method for=Event>initEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>If <a>context object</a>'s <a>dispatch flag</a> is set, terminate
 these steps.

 <li><a>Initialize</a> the
 <a>context object</a> with <var>type</var>, <var>bubbles</var>, and
 <var>cancelable</var>.
</ol>

Note: As <a>events</a> have constructors
{{Event/initEvent()}} is superfluous. However,
it has to be supported for legacy content.


<h3 id='interface-customevent'>
Interface {{CustomEvent}}</h3>

<pre class=idl>
[Constructor(DOMString type, optional CustomEventInit eventInitDict),
 Exposed=(Window,Worker)]
interface CustomEvent : Event {
  readonly attribute any detail;

  void initCustomEvent(DOMString type, boolean bubbles, boolean cancelable, any detail);
};

dictionary CustomEventInit : EventInit {
  any detail = null;
};
</pre>

<a>Events</a> using the
{{CustomEvent}} interface can be used to carry custom data.

<dl class=domintro>
 <dt><code><var>event</var> = new <a constructor lt="CustomEvent()">CustomEvent</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
 <dd>Works analogously to the constructor for {{Event}} except
 that the optional <var>eventInitDict</var> argument now
 allows for setting the {{CustomEvent/detail}} attribute
 too.IDL

 <dt><code><var>event</var> . {{CustomEvent/detail}}</code>
 <dd>Returns any custom data <var>event</var> was created with.
 Typically used for synthetic events.

 <!-- initCustomEvent is dead -->
</dl>

The <dfn attribute for=CustomEvent>detail</dfn> attribute
must return the value it was initialized to.

The
<dfn method for=CustomEvent>initCustomEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>, <var>detail</var>)</dfn>
method must, when invoked, run these steps:

<ol>
 <li>If <a>context object</a>'s <a>dispatch flag</a> is set, terminate
 these steps.

 <li><a>Initialize</a> the
 <a>context object</a> with <var>type</var>, <var>bubbles</var>, and
 <var>cancelable</var>.

 <li>Set <a>context object</a>'s {{CustomEvent/detail}}
 attribute to <var>detail</var>.
</ol>


<h3 id='constructing-events'>
Constructing events</h3>

When a <dfn id=concept-event-constructor>constructor</dfn> of the {{Event}}
interface, or of an interface that inherits from the {{Event}} interface, is
invoked, these steps must be run:

<ol>
 <li>Create an <a>event</a> that uses the
 interface the constructor was invoked upon.

 <li>Set its <a>initialized flag</a>.

 <li>Initialize the {{Event/type}} attribute to
 the <var>type</var> argument.

 <li>If there is an <var>eventInitDict</var> argument then for each
 <a>dictionary member</a> defined therein find
 the attribute on <a>event</a> whose
 <a>identifier</a> matches the key of
 the <a>dictionary member</a> and then
 set the attribute to the value of that
 <a>dictionary member</a>.

 <li>Return the <a>event</a>.
</ol>


<h3 id='defining-event-interfaces'>
Defining event interfaces</h3>

In general, when defining a new interface that inherits from
{{Event}} please always ask feedback from the WHATWG or the
W3C WebApps WG community.

The {{CustomEvent}} interface can be used as starting point.
However, do not introduce any <code>init<var>*</var>Event()</code>
methods as they are redundant with constructors. Interfaces that inherit
from the {{Event}} interface that have such a method only have it
for historical reasons.


<h3 id='interface-eventtarget'>
Interface {{EventTarget}}</h3>

<pre class=idl>
[Exposed=(Window,Worker)]
interface EventTarget {
  void addEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
  void removeEventListener(DOMString type, EventListener? callback, optional boolean capture = false);
  boolean dispatchEvent(Event event);
};

callback interface EventListener {
  void handleEvent(Event event);
};
</pre>

{{EventTarget}} is an object to which an
<a>event</a> is
<a>dispatched</a> when something has
occurred. Each {{EventTarget}} has an associated list of
<a>event listeners</a>.

An <dfn id=concept-event-listener>event listener</dfn> associates a
callback with a specific <a>event</a>. Each
<a>event listener</a> consists of a
<b>type</b> (of the <a>event</a>),
<b>callback</b>, and <b>capture</b> variable.

Note: The <b>callback</b> is named {{EventListener}} for
historical reasons. As can be seen from the definition above, an
<a>event listener</a> is a more broad
concept.

<dl class=domintro>
 <dt><code><var>target</var> . <a method lt="addEventListener()">addEventListener</a>(<var>type</var>, <var>callback</var> [, <var>capture</var> = false])</code>
 <dd>
  Appends an <a>event listener</a>
  for <a>events</a> whose
  {{Event/type}} attribute value is
  <var>type</var>. The <var>callback</var> argument sets the
  <b>callback</b> that will be invoked when the
  <a>event</a> is
  <a>dispatched</a>. When set to true,
  the <var>capture</var> argument prevents <b>callback</b> from being invoked when
  the <a>event</a>'s
  {{Event/eventPhase}} attribute value is
  {{Event/BUBBLING_PHASE}}. When false, <b>callback</b>
  will not be invoked when <a>event</a>'s
  {{Event/eventPhase}} attribute value is
  {{Event/CAPTURING_PHASE}}. Either way,
  <b>callback</b> will be invoked when <a>event</a>'s
  {{Event/eventPhase}} attribute value is
  {{Event/AT_TARGET}}.

  The <a>event listener</a> is
  appended to <var>target</var>'s list of
  <a>event listeners</a> and is not
  appended if it is a duplicate (the
  <a>event listeners</a> in the list are
  unique).

 <dt><code><var>target</var> . <a method lt="removeEventListener()">removeEventListener</a>(<var>type</var>, <var>callback</var> [, <var>capture</var> = false])</code>
 <dd>Remove the <a>event listener</a>
 in <var>target</var>'s list of
 <a>event listeners</a> with the same
 <var>type</var>, <var>callback</var>, and
 <var>capture</var>.

 <dt><code><var>target</var> . <a method lt="dispatchEvent()">dispatchEvent</a>(<var>event</var>)</code>
 <dd><a>Dispatches</a> a synthetic
 event <var>event</var> to <var>target</var> and returns true
 if either <var>event</var>'s
 {{Event/cancelable}} attribute value is false
 or it's {{Event/preventDefault()}} method
 was not invoked, and false otherwise.
</dl>

The
<dfn method for=EventTarget>addEventListener(<var>type</var>, <var>callback</var>, <var>capture</var>)</dfn>
method must run these steps:
<ol>
 <li>If <var>callback</var> is null, terminate these steps.
 <li>Append an <a>event listener</a>
 to the associated list of
 <a>event listeners</a> with <b>type</b>
 set to <var>type</var>, <b>callback</b> set to <var>callback</var>, and
 <b>capture</b> set to <var>capture</var>, unless there
 already is an <a>event listener</a> in
 that list with the same <b>type</b>, <b>callback</b>, and <b>capture</b>.
</ol>

The
<dfn method for=EventTarget>removeEventListener(<var>type</var>, <var>callback</var>, <var>capture</var>)</dfn>
method must run these steps:
<ol>
 <li>Remove an <a>event listener</a>
 from the associated list of
 <a>event listeners</a>, whose
 <b>type</b> is <var>name</var>, <b>callback</b> is <var>callback</var>, and
 <b>capture</b> is <var>capture</var>.
</ol>

The
<dfn method for=EventTarget>dispatchEvent(<var>event</var>)</dfn>
method must run these steps:
<ol>
 <li>If <var>event</var>'s <a>dispatch flag</a> is set, or if
 its <a>initialized flag</a> is not set,
 <a>throw</a> an
 {{InvalidStateError}} exception.
 <li>Initialize <var>event</var>'s
 {{Event/isTrusted}} attribute to false.
 <li><a>Dispatch</a> the
 <var>event</var> and return the value that returns.
</ol>


<h3 id='dispatching-events'>
Dispatching events</h3>

To <dfn id=concept-event-dispatch>dispatch</dfn> an
<a>event</a> to a given object, optionally with
a <var>target override</var>, run these steps:

<ol>
 <li>Let <var>event</var> be the
 <a>event</a> that is dispatched.

 <li>Set <var>event</var>'s <a>dispatch flag</a>.

 <li>Initialize <var>event</var>'s
 {{Event/target}} attribute to
 <var>target override</var>, if it is given, or the object to which
 <var>event</var> is dispatched otherwise.

 <li>If <var>event</var>'s
 {{Event/target}} attribute value is
 <a>participating</a> in a
 <a>tree</a>, let <var>event path</var> be a
 static ordered list of all its
 <a>ancestors</a> in
 <a>tree order</a>, and let
 <var>event path</var> be the empty list otherwise.

 <li>Initialize <var>event</var>'s
 {{Event/eventPhase}} attribute to
 {{Event/CAPTURING_PHASE}}.

 <li>For each object in <var>event path</var>,
 <a>invoke</a> its
 <a>event listeners</a> with event
 <var>event</var>, as long as <var>event</var>'s
 <a>stop propagation flag</a> is unset.

 <li>Initialize <var>event</var>'s
 {{Event/eventPhase}} attribute to
 {{Event/AT_TARGET}}.

 <li><a>Invoke</a> the
 <a>event listeners</a> of
 <var>event</var>'s {{Event/target}}
 attribute value with <var>event</var>, if <var>event</var>'s
 <a>stop propagation flag</a> is unset.

 <li>
  If <var>event</var>'s
  {{Event/bubbles}} attribute value is true, run
  these substeps:

  <ol>
   <li>Reverse the order of <var>event path</var>.

   <li>Initialize <var>event</var>'s
   {{Event/eventPhase}} attribute to
   {{Event/BUBBLING_PHASE}}.

   <li>For each object in <var>event path</var>,
   <a>invoke</a> its
   <a>event listeners</a>, with event
   <var>event</var> as long as <var>event</var>'s
   <a>stop propagation flag</a> is unset.
  </ol>

 <li>Unset <var>event</var>'s <a>dispatch flag</a>.

 <li>Initialize <var>event</var>'s
 {{Event/eventPhase}} attribute to
 {{Event/NONE}}.

 <li>Initialize <var>event</var>'s
 {{Event/currentTarget}} attribute to null.

 <li>Return false if <var>event</var>'s <a>canceled flag</a>
 is set, and true otherwise.
</ol>


To <dfn id=concept-event-listener-invoke>invoke</dfn> the
<a>event listeners</a> for an object with an
event run these steps:
<ol>
 <li>Let <var>event</var> be the
 <a>event</a> for which the
 <a>event listeners</a> are invoked.
 <li>Let <var>listeners</var> be a copy of the
 <a>event listeners</a> associated with
 the object for which these steps are run.
 <li>Initialize <var>event</var>'s
 {{Event/currentTarget}} attribute to the
 object for which these steps are run.
 <li>
  Then run these substeps for each
  <a>event listener</a> in
  <var>listeners</var>:
  <ol>
   <li>If <var>event</var>'s
   <a>stop immediate propagation flag</a> is set, terminate the
   <a>invoke</a> algorithm.
   <li>Let <var>listener</var> be the
   <a>event listener</a>.
   <li>If <var>event</var>'s {{Event/type}}
   attribute value is not <var>listener</var>'s <b>type</b>, terminate
   these substeps (and run them for the next
   <a>event listener</a>).
   <li>If <var>event</var>'s
   {{Event/eventPhase}} attribute value is
   {{Event/CAPTURING_PHASE}} and
   <var>listener</var>'s <b>capture</b> is false, terminate these
   substeps (and run them for the next
   <a>event listener</a>).
   <li>If <var>event</var>'s
   {{Event/eventPhase}} attribute value is
   {{Event/BUBBLING_PHASE}} and
   <var>listener</var>'s <b>capture</b> is true, terminate these
   substeps (and run them for the next
   <a>event listener</a>).
   <li>Call <var>listener</var>'s <b>callback</b>'s
   {{EventListener/handleEvent()}}, with the event passed to
   this algorithm as the first argument and <var>event</var>'s
   {{Event/currentTarget}} attribute value as
   <a>callback this value</a>. If this throws any exception,
   <a>report the exception</a>.
  </ol>

</ol>


<h3 id='firint-vents'>
Firing events</h3>

To
<dfn id=concept-event-fire lt="fire an event">fire an event named <var>e</var></dfn>
means that a new <a>event</a> using the
{{Event}} interface, with its
{{Event/type}} attribute initialized to
<var>e</var>, and its {{Event/isTrusted}}
attribute initialized to <code>true</code>, is to be
<a>dispatched</a> to the given object.

Note: Fire in the context of DOM is short for creating, initializing, and
<a>dispatching</a> an
<a>event</a>.
<a>Fire an event</a> makes that process easier to write
down. If the <a>event</a> needs its {{Event/bubbles}} or
{{Event/cancelable}} attribute initialized, one could write
"<a>fire an event</a> named
<code>submit</code> with its {{Event/cancelable}} attribute
initialized to true".



<h2 id='nodes'>
Nodes</h2>

<h3 id='introduction-to-the-dom'>
Introduction to "The DOM"</h3>

In its original sense, "The DOM" is an API for
accessing and manipulating documents (in particular, HTML and XML
documents). In this specification, the term "document" is used for any
markup-based resource, ranging from short static documents to long essays or
reports with rich multimedia, as well as to fully-fledged interactive
applications.

These documents are presented as a
<a>node tree</a>. Some of the
<a>nodes</a> in the
<a>tree</a> can have
<a>children</a>, while others are leaves.

To illustrate, consider this HTML document:

<pre class='lang-markup'>
&lt;!DOCTYPE html>
&lt;html class=e>
 &lt;head>&lt;title>Aliens?&lt;/title>&lt;/head>
 &lt;body>Why yes.&lt;/body>
&lt;/html>
</pre>

It is represented as follows:

<ul class="domTree">
 <li>
  <a>Document</a>
  <ul>
   <li class="t10"><a>Doctype</a>: <code>html</code>
   <li class="t1">{{Element}}: <code>html</code> <span class="t2"><code class="attribute name">class</code>="<code class="attribute value">e</code>"</span>
    <ul>
     <li class="t1">
      {{Element}}: <code>head</code>
      <ul>
       <li class="t1">
        {{Element}}: <code>title</code>
        <ul>
         <li class="t3">{{Text}}: <span>Aliens?</span>
        </ul>

      </ul>

     <li class="t3">{{Text}}: <span>⏎␣</span>
     <li class="t1">
      {{Element}}: <code>body</code>
      <ul>
       <li class="t3">{{Text}}: <span>Why yes.⏎</span>
      </ul>

    </ul>

  </ul>

</ul>

<!--
http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0D%0A%3Chtml%20class%3De%3E%0D%0A%20%3Chead%3E%3Ctitle%3EAliens%3F%3C%2Ftitle%3E%3C%2Fhead%3E%0D%0A%20%3Cbody%3EWhy%20yes.%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E
-->

Note that, due to the magic that is
<a>HTML parsing</a>, not all
<a>ASCII whitespace</a> were turned into
{{Text}} <a>nodes</a>, but the general
concept is clear. Markup goes in, a <a>tree</a> of
<a>nodes</a> comes out.
<!-- You /can/ explain that! harharhar -->

Note: The most excellent
<a href="http://software.hixie.ch/utilities/js/live-dom-viewer/">Live DOM Viewer</a>
can be used to explore this matter in more detail.


<h3 id='node-trees'>
Node tree</h3>

Objects implementing the {{Document}},
{{DocumentFragment}}, {{DocumentType}},
{{Element}}, {{Text}}, {{ProcessingInstruction}},
or {{Comment}} interfaces (simply called
<dfn id=concept-node>nodes</dfn>)
<a>participate</a> in a
<a>tree</a>, simply named the
<dfn id=concept-node-tree>node tree</dfn>.

A <a>node tree</a> is constrained as
follows, expressed as a relationship between the type of
<a>node</a> and its allowed
<a>children</a>:
<dl>
 <dt>{{Document}}
 <dd>
  In <a>tree order</a>:
  <ol>
   <li>Zero or more nodes each of which is either
   {{ProcessingInstruction}} or {{Comment}}.
   <li>Optionally one {{DocumentType}} node.
   <li>Zero or more nodes each of which is either
   {{ProcessingInstruction}} or {{Comment}}.
   <li>Optionally one {{Element}} node.
   <li>Zero or more nodes each of which is either
   {{ProcessingInstruction}} or {{Comment}}.
  </ol>
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <dd>Zero or more nodes each of which is one of {{Element}},
 {{ProcessingInstruction}}, {{Comment}}, or
 {{Text}}.
 <dt>{{DocumentType}}
 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd>None.
</dl>
<!--AttrExodus -->

The <dfn id=concept-node-length for="Node">length</dfn> of a
<a>node</a> <var>node</var> depends on
<var>node</var>:
<dl class=switch>
 <dt>{{DocumentType}}
 <dd>Zero.

 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd>Its {{CharacterData/length}} attribute
 value.

 <dt>Any other node
 <dd>Its number of <a>children</a>.
</dl>

A <a>node</a> is considered
<dfn id=concept-node-empty for="Node">empty</dfn> if its
<a>length</a> is zero.


<h4 id='mutation-algorithms'>
Mutation algorithms</h4>

To <dfn id=concept-node-ensure-pre-insertion-validity>ensure pre-insertion validity</dfn>
of a <var>node</var> into a <var>parent</var> before a
<var>child</var>, run these steps:

<ol>
 <li>If <var>parent</var> is not a {{Document}},
 {{DocumentFragment}}, or {{Element}}
 <a>node</a>,
 <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>If <var>node</var> is a
 <a>host-including inclusive ancestor</a>
 of <var>parent</var>, <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>If <var>child</var> is not null and its
 <a>parent</a> is not
 <var>parent</var>, <a>throw</a> a
 {{NotFoundError}} exception.

 <li>If <var>node</var> is not a
 {{DocumentFragment}}, {{DocumentType}},
 {{Element}}, {{Text}},
 {{ProcessingInstruction}}, or {{Comment}}
 <a>node</a>,
 <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>If either <var>node</var> is a {{Text}}
 <a>node</a> and <var>parent</var> is a
 <a>document</a>, or <var>node</var> is a
 <a>doctype</a> and <var>parent</var> is
 not a <a>document</a>,
 <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>
  If <var>parent</var> is a
  <a>document</a>, and any of the statements below, switched
  on <var>node</var>, are true, <a>throw</a> a
  {{HierarchyRequestError}}.

  <dl class=switch>
   <dt>{{DocumentFragment}} <a>node</a>
   <dd>
    If <var>node</var> has more than one
    <a>element</a> <a>child</a>
    or has a {{Text}} <a>node</a>
    <a>child</a>.

    Otherwise, if <var>node</var> has one
    <a>element</a>
    <a>child</a> and either <var>parent</var> has an
    <a>element</a>
    <a>child</a>, <var>child</var> is a
    <a>doctype</a>, or <var>child</var> is not null and
    a <a>doctype</a> is
    <a>following</a> <var>child</var>.
    <!--"inclusively following"-->

   <dt><a>element</a>
   <dd><var>parent</var> has an <a>element</a>
   <a>child</a>, <var>child</var> is a
   <a>doctype</a>, or <var>child</var> is not null and a
   <a>doctype</a> is
   <a>following</a> <var>child</var>.
   <!--"inclusively following"-->

   <dt><a>doctype</a>
   <dd><var>parent</var> has a <a>doctype</a>
   <a>child</a>, an
   <a>element</a> is
   <a>preceding</a> <var>child</var>, or
   <var>child</var> is null and <var>parent</var> has an
   <a>element</a> <a>child</a>.
  </dl>
</ol>

To <dfn id=concept-node-pre-insert>pre-insert</dfn> a
<var>node</var> into a <var>parent</var> before a
<var>child</var>, run these steps:

<ol>
 <li><a>Ensure pre-insertion validity</a>
 of <var>node</var> into <var>parent</var> before
 <var>child</var>.

 <li>Let <var>reference child</var> be <var>child</var>.

 <li>If <var>reference child</var> is <var>node</var>, set it
 to <var>node</var>'s
 <a>next sibling</a>.

 <li><a>Adopt</a>
 <var>node</var> into <var>parent</var>'s
 <a>node document</a>.

 <li><a for="node">Insert</a> <var>node</var>
 into <var>parent</var> before <var>reference child</var>.

 <li>Return <var>node</var>.
 <!-- technically this is post-insert -->
</ol>

<a lt="Other applicable specifications">Specifications</a> may define
<dfn id=concept-node-insert-ext>insertion steps</dfn> for all or some
<a>nodes</a>. The algorithm is passed <var>newNode</var> as
indicated in the <a for="node">insert</a> algorithm below.

To <dfn id=concept-node-insert for="node">insert</dfn> a <var>node</var>
into a <var>parent</var> before a <var>child</var>, optionally
with a <i>suppress observers flag</i>, run these steps:

<ol>
 <li>Let <var>count</var> be the number of
 <a>children</a> of <var>node</var> if
 it is a {{DocumentFragment}} <a>node</a>,
 and one otherwise.

 <li>
  If <var>child</var> is non-null, run these substeps:

  <ol>
   <li>For each <a>range</a> whose
   <a>start node</a> is
   <var>parent</var> and
   <a>start offset</a> is greater than
   <var>child</var>'s <a>index</a>,
   increase its <a>start offset</a> by
   <var>count</var>.

   <li>For each <a>range</a> whose
   <a>end node</a> is
   <var>parent</var> and
   <a>end offset</a> is greater than
   <var>child</var>'s <a>index</a>,
   increase its <a>end offset</a> by
   <var>count</var>.
  </ol>

 <li>Let <var>nodes</var> be <var>node</var>'s
 <a>children</a> if <var>node</var> is
 a {{DocumentFragment}} <a>node</a>, and a
 list containing solely <var>node</var> otherwise.

 <li>
  If <var>node</var> is a {{DocumentFragment}}
  <a>node</a>, <a>queue a mutation record</a>
  of "<code>childList</code>" for <var>node</var> with removedNodes
  <var>nodes</var>.

  Note: This step intentionally does not pay attention to the
  <i>suppress observers flag</i>.

 <li>If <var>node</var> is a {{DocumentFragment}}
 <a>node</a>,
 <a>remove</a> its
 <a>children</a> with the
 <i>suppress observers flag</i> set.

 <li>If <i>suppress observers flag</i> is unset,
 <a>queue a mutation record</a> of "<code>childList</code>" for
 <var>parent</var> with addedNodes <var>nodes</var>,
 nextSibling <var>child</var>, and previousSibling
 <var>child</var>'s
 <a>previous sibling</a>
 or <var>parent</var>'s
 <a>last child</a> if
 <var>child</var> is null.

 <li>
  For each <var>newNode</var> in <var>nodes</var>, in
  <a>tree order</a>, run these substeps:

  <ol>
   <li>Insert <var>newNode</var> into <var>parent</var> before
   <var>child</var> or at the end of <var>parent</var> if
   <var>child</var> is null.

   <li>Run the <a>insertion steps</a> with
   <var>newNode</var>.
  </ol>
</ol>


To <dfn id=concept-node-append>append</dfn> a <var>node</var>
to a <var>parent</var>,
<a>pre-insert</a> <var>node</var>
into <var>parent</var> before null.


To <dfn id=concept-node-replace>replace</dfn> a <var>child</var>
with <var>node</var> within a <var>parent</var>, run these
steps:

<!-- Step 1-5 could be shared with concept-node-pre-insert, although step 3
     in pre-insert is a superset (which is fine). Step 6.1.1 could also be
     shared. -->

<ol>
 <li>If <var>parent</var> is not a {{Document}},
 {{DocumentFragment}}, or {{Element}}
 <a>node</a>,
 <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>If <var>node</var> is a
 <a>host-including inclusive ancestor</a>
 of <var>parent</var>, <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>If <var>child</var>'s
 <a>parent</a> is not
 <var>parent</var>, <a>throw</a> a
 {{NotFoundError}} exception.

 <li>If <var>node</var> is not a
 {{DocumentFragment}}, {{DocumentType}},
 {{Element}}, {{Text}},
 {{ProcessingInstruction}}, or {{Comment}}
 <a>node</a>,
 <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>If either <var>node</var> is a {{Text}}
 <a>node</a> and <var>parent</var> is a
 <a>document</a>, or <var>node</var> is a
 <a>doctype</a> and <var>parent</var> is
 not a <a>document</a>,
 <a>throw</a> a
 {{HierarchyRequestError}}.

 <li>
  If <var>parent</var> is a
  <a>document</a>, and any of the statements below, switched
  on <var>node</var>, are true, <a>throw</a> a
  {{HierarchyRequestError}}.

  <dl class=switch>
   <dt>{{DocumentFragment}} <a>node</a>
   <dd>
    If <var>node</var> has more than one
    <a>element</a> <a>child</a>
    or has a {{Text}} <a>node</a>
    <a>child</a>.

    Otherwise, if <var>node</var> has one
    <a>element</a> <a>child</a>
    and either <var>parent</var> has an <a>element</a>
    <a>child</a> that is not <var>child</var> or a
    <a>doctype</a> is
    <a>following</a> <var>child</var>.

   <dt><a>element</a>
   <dd><var>parent</var> has an <a>element</a>
   <a>child</a> that is not <var>child</var> or a
   <a>doctype</a> is
   <a>following</a> <var>child</var>.

   <dt><a>doctype</a>
   <dd><var>parent</var> has a <a>doctype</a>
   <a>child</a> that is not <var>child</var>, or an
   <a>element</a> is
   <a>preceding</a> <var>child</var>.
  </dl>

  Note: The above statements differ from the
  <a>pre-insert</a> algorithm.

 <li>Let <var>reference child</var> be <var>child</var>'s
 <a>next sibling</a>.

 <li>If <var>reference child</var> is <var>node</var>, set it
 to <var>node</var>'s
 <a>next sibling</a>.

 <li><a>Adopt</a>
 <var>node</var> into <var>parent</var>'s
 <a>node document</a>.

 <li><a>Remove</a> <var>child</var>
 from its <var>parent</var> with the
 <i>suppress observers flag</i> set.

 <li><a for="node">Insert</a> <var>node</var>
 into <var>parent</var> before <var>reference child</var> with
 the <i>suppress observers flag</i> set.

 <li>Let <var>nodes</var> be <var>node</var>'s
 <a>children</a> if <var>node</var> is
 a {{DocumentFragment}} <a>node</a>, and a
 list containing solely <var>node</var> otherwise.

 <li><a>Queue a mutation record</a> of "<code>childList</code>" for
 target <var>parent</var> with addedNodes
 <var>nodes</var>, removedNodes a list solely containing
 <var>child</var>, nextSibling <var>reference child</var>, and
 previousSibling <var>child</var>'s
 <a>previous sibling</a>.

 <li>Return <var>child</var>.
</ol>


To <dfn id=concept-node-replace-all>replace all</dfn> with a
<var>node</var> within a <var>parent</var>, run these steps:

<ol>
 <li>If <var>node</var> is not null,
 <a>adopt</a> <var>node</var> into
 <var>parent</var>'s
 <a>node document</a>.

 <li>Let <var>removedNodes</var> be <var>parent</var>'s
 <a>children</a>.

 <li>Let <var>addedNodes</var> be the empty list if <var>node</var> is
 null, <var>node</var>'s <a>children</a> if
 <var>node</var> is a {{DocumentFragment}}
 <a>node</a>, and a list containing <var>node</var>
 otherwise.

 <li><a>Remove</a> all
 <var>parent</var>'s <a>children</a>, in
 <a>tree order</a>, with the
 <i>suppress observers flag</i> set.

 <li>If <var>node</var> is not null,
 <a for="node">insert</a> <var>node</var> into
 <var>parent</var> before null with the <i>suppress observers flag</i> set.

 <li><a>Queue a mutation record</a> of "<code>childList</code>" for
 <var>parent</var> with addedNodes <var>addedNodes</var> and
 removedNodes <var>removedNodes</var>.
</ol>

Note: This algorithm does not make any checks with regards to the
<a>node tree</a> constraints. Use it wisely.


To <dfn id=concept-node-pre-remove>pre-remove</dfn> a
<var>child</var> from a <var>parent</var>, run these steps:

<ol>
 <li>If <var>child</var>'s
 <a>parent</a> is not
 <var>parent</var>, <a>throw</a> a
 {{NotFoundError}} exception.

 <li><a>Remove</a> <var>child</var>
 from <var>parent</var>.

 <li>Return <var>child</var>.
 <!-- technically this is post-remove -->
</ol>


<a lt="Other applicable specifications">Specifications</a> may define
<dfn id=concept-node-remove-ext>removing steps</dfn> for all or some
<a>nodes</a>. The algorithm is passed <var>removedNode</var>,
<var>oldParent</var>, and <var>oldPreviousSibling</var>, as indicated in the
<a>remove</a> algorithm below.

To <dfn id=concept-node-remove>remove</dfn> a <var>node</var>
from a <var>parent</var>, optionally with
<i>suppress observers flag</i> set, run these steps:

<ol>
 <li>Let <var>index</var> be <var>node</var>'s
 <a>index</a>.

 <li>For each <a>range</a> whose
 <a>start node</a> is an
 <a>inclusive descendant</a> of
 <var>node</var>, set its
 <a>start</a> to
 (<var>parent</var>, <var>index</var>).

 <li>For each <a>range</a> whose
 <a>end node</a> is an
 <a>inclusive descendant</a> of
 <var>node</var>, set its
 <a>end</a> to
 (<var>parent</var>, <var>index</var>).

 <li>For each <a>range</a> whose
 <a>start node</a> is
 <var>parent</var> and
 <a>start offset</a> is greater than
 <var>index</var>, decrease its
 <a>start offset</a> by one.

 <li>For each <a>range</a> whose
 <a>end node</a> is
 <var>parent</var> and
 <a>end offset</a> is greater than
 <var>index</var>, decrease its
 <a>end offset</a> by one.

 <li>Let <var>oldPreviousSibling</var> be <var>node</var>'s
 <a>previous sibling</a>

 <li>If <i>suppress observers flag</i> is unset,
 <a>queue a mutation record</a> of "<code>childList</code>" for
 <var>parent</var> with removedNodes a list solely containing
 <var>node</var>, nextSibling <var>node</var>'s
 <a>next sibling</a>,
 and previousSibling <var>oldPreviousSibling</var>.

 <li>For each <a>ancestor</a>
 <var>ancestor</var> of <var>node</var>, if
 <var>ancestor</var> has any
 <a>registered observers</a> whose
 <b>options</b>'s
 {{MutationObserverInit/subtree}} is true, then
 for each such <a>registered observer</a> <var>registered</var>, append a
 <a>transient registered observer</a> whose <b>observer</b> and
 <b>options</b> are identical to those of <var>registered</var> and <b>source</b>
 which is <var>registered</var> to <var>node</var>'s list of
 <a>registered observers</a>.

 <li>Remove <var>node</var> from its <var>parent</var>.

 <li>Run the <a>removing steps</a> with
 <var>node</var>, <var>parent</var>, and <var>oldPreviousSibling</var>.
</ol>


<h4 id='interface-nonelementparentnode'>
Interface <code>NonElementParentNode</code></h4>

<p class="note no-backref">The
{{NonElementParentNode/getElementById()}} method is not
on <a>elements</a> for compatibility with older versions of
jQuery. If a time comes where that version of jQuery has disappeared, we might be able to
support it.

<pre class=idl>
[NoInterfaceObject,
 Exposed=Window]
interface NonElementParentNode {
  Element? getElementById(DOMString elementId);
};
Document implements NonElementParentNode;
DocumentFragment implements NonElementParentNode;
</pre>

<dl class=domintro>
 <dt><code><var>node</var> . <a method for=NonElementParentNode lt="getElementById()">getElementById</a>(<var>elementId</var>)</code>
 <dd>Returns the first <a>element</a> within
 <var>node</var>'s <a>descendants</a> whose
 <a>ID</a> is <var>elementId</var>.
</dl>

The
<dfn method for=NonElementParentNode>getElementById(<var>elementId</var>)</dfn>
method must return the first <a>element</a>, in
<a>tree order</a>, within <a>context object</a>'s
<a>descendants</a>, whose
<a>ID</a> is <var>elementId</var>, and null if there is no
such <a>element</a> otherwise.


<h4 id='interface-parentnode'>
Interface <code>ParentNode</code></h4>

The <dfn>mutation method macro</dfn>:

<ol>
 <li>Let <var>node</var> be null.

 <li>Replace each string in <var>nodes</var> with a
 {{Text}} <a>node</a> whose
 <a>data</a> is the string value.

 <li>
  If <var>nodes</var> contains more than one
  <a>node</a>, set <var>node</var> to a new
  {{DocumentFragment}} and
  <a>append</a> each
  <a>node</a> in <var>nodes</var> to it. Rethrow any
  exceptions.

  Otherwise, set <var>node</var> to the single
  <a>node</a> <var>nodes</var> contains.
</ol>

<pre class=idl>
[NoInterfaceObject,
 Exposed=Window]
interface ParentNode {
  [SameObject] readonly attribute HTMLCollection children;
  readonly attribute Element? firstElementChild;
  readonly attribute Element? lastElementChild;
  readonly attribute unsigned long childElementCount;

  [Unscopeable] void prepend((Node or DOMString)... nodes);
  [Unscopeable] void append((Node or DOMString)... nodes);

  [Unscopeable] Element? query(DOMString relativeSelectors);
  [NewObject, Unscopeable] Elements queryAll(DOMString relativeSelectors);
  Element? querySelector(DOMString selectors);
  [NewObject] NodeList querySelectorAll(DOMString selectors);
};
Document implements ParentNode;
DocumentFragment implements ParentNode;
Element implements ParentNode;
</pre>

<dl class=domintro>
 <dt><code><var>collection</var> = <var>node</var> . {{ParentNode/children}}</code>
 <dd>Returns the <a>child</a> <a>elements</a>.

 <dt><code><var>element</var> = <var>node</var> . {{ParentNode/firstElementChild}}</code>
 <dd>Returns the first <a>child</a> that is an <a>element</a>, and null otherwise.

 <dt><code><var>element</var> = <var>node</var> . {{ParentNode/lastElementChild}}</code>
 <dd>Returns the last <a>child</a> that is an <a>element</a>, and null otherwise.

 <!-- childElementCount is redundant -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="prepend()">prepend</a>(<var>nodes</var>)</code>
 <dd>
  Inserts <var>nodes</var> before the
  <a>first child</a> of
  <var>node</var>, while replacing strings in <var>nodes</var>
  with equivalent {{Text}} <a>nodes</a>.

  <a>Throws</a> a
  {{HierarchyRequestError}} if the constraints of the
  <a>node tree</a> are violated.
  <!-- "NotFoundError" is impossible -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="append()">append</a>(<var>nodes</var>)</code>
 <dd>
  Inserts <var>nodes</var> after the
  <a>last child</a> of
  <var>node</var>, while replacing strings in <var>nodes</var>
  with equivalent {{Text}} <a>nodes</a>.

  <a>Throws</a> a
  {{HierarchyRequestError}} if the constraints of the
  <a>node tree</a> are violated.
  <!-- "NotFoundError" is impossible -->

 <dt><code><var>node</var> . <a method for=ParentNode lt="query()">query</a>(<var>relativeSelectors</var>)</code>
 <dd>
  Returns the first <a>element</a> that is a
  <a>descendant</a> of <var>node</var> that
  matches <var>relativeSelectors</var>.

 <dt><code><var>node</var> . <a method for=ParentNode lt="queryAll()">queryAll</a>(<var>relativeSelectors</var>)</code>
 <dd>
  Returns all <a>element</a>
  <a>descendants</a> of <var>node</var> that
  match <var>relativeSelectors</var>.

 <dt><code><var>node</var> . <a method for=ParentNode lt="querySelector()">querySelector</a>(<var>selectors</var>)</code>
 <dd>
  Returns the first <a>element</a> that is a
  <a>descendant</a> of <var>node</var> that
  matches <var>selectors</var>.

 <dt><code><var>node</var> . <a method for=ParentNode lt="querySelectorAll()">querySelectorAll</a>(<var>selectors</var>)</code>
 <dd>
  Returns all <a>element</a>
  <a>descendants</a> of <var>node</var> that
  match <var>selectors</var>.
</dl>

The <dfn attribut for=ParentNode>children</dfn>
attribute must return an {{HTMLCollection}}
<a>collection</a> rooted at the
<a>context object</a> matching only
<a>element</a>
<a>children</a>.

The
<dfn attribute for=ParentNode>firstElementChild</dfn>
attribute must return the first <a>child</a>
that is an <a>element</a>, and null otherwise.

The
<dfn attribute for=ParentNode>lastElementChild</dfn>
attribute must return the last <a>child</a>
that is an <a>element</a>, and null otherwise.

The
<dfn attribute for=ParentNode>childElementCount</dfn>
attribute must return the number of <a>children</a> of the <a>context object</a> that are <a>elements</a>.

The
<dfn method for=ParentNode>prepend(<var>nodes</var>)</dfn>
method must run these steps:

<ol>
 <li>Run the <a>mutation method macro</a>.

 <li><a>Pre-insert</a> <var>node</var> into the <a>context object</a>
  before the <a>context object</a>'s <a>first child</a>.
</ol>

The
<dfn method for=ParentNode>append(<var>nodes</var>)</dfn>
method must run these steps:

<ol>
 <li>Run the <a>mutation method macro</a>.

 <li><a>Append</a>
 <var>node</var> to the <a>context object</a>.
</ol>

To <dfn>match a relative selectors string</dfn> <var>relativeSelectors</var>
against a <var>set</var>, run these steps:

<ol>
 <li>Let <var>s</var> be the result of
 <a>parse a relative selector</a> from
 <var>relativeSelectors</var> against <var>set</var>.
 [[!SELECTORS4]]

 <li>If <var>s</var> is failure, <a>throw</a> a {{SyntaxError}}.

 <li>Return the result of <a>evaluate a selector</a> <var>s</var>
  using <a>:scope elements</a> <var>set</var>. [[!SELECTORS4]]
</ol>

The
<dfn method for=ParentNode>query(<var>relativeSelectors</var>)</dfn>
method must return the first result of running
<a>match a relative selectors string</a> <var>relativeSelectors</var> against
a set consisting of <a>context object</a>, and null if the result is an empty list.

The
<dfn method for=ParentNode>queryAll(<var>relativeSelectors</var>)</dfn>
method must return an {{Elements}} array initialized with the result of running
<a>match a relative selectors string</a> <var>relativeSelectors</var> against
a set consisting of <a>context object</a>.

To <dfn>scope-match a selectors string</dfn> <var>selectors</var> against a
<var>node</var>, run these steps:

<ol>
 <li>Let <var>s</var> be the result of
 <a>parse a selector</a> <var>selectors</var>.
 [[!SELECTORS4]]

 <li>If <var>s</var> is failure, <a>throw</a> a
 {{SyntaxError}}.

 <li>Return the result of <a>evaluate a selector</a>
 <var>s</var> against
 <var>node</var>'s <a for=tree>root</a> using
 <a>scoping root</a> <var>node</var> and
 scoping method
 <a>scope-filtered</a>.
 [[!SELECTORS4]].
</ol>

The
<dfn method for=ParentNode>querySelector(<var>selectors</var>)</dfn>
method must return the first result of running <a>scope-match a selectors string</a>
<var>selectors</var> against the <a>context object</a>, and null if the result
is an empty list otherwise.

The
<dfn method for="ParentNode">querySelectorAll(<var>selectors</var>)</dfn>
method must return the <a lt="static collection">static</a> result of
running <a>scope-match a selectors string</a> <var>selectors</var> against the
<a>context object</a>.


<h4 id='interface-nondocumenttypechildnode'>
Interface {{NonDocumentTypeChildNode}}</h4>

Note: The {{previousElementSibling}} and {{nextElementSibling}}
attributes have been removed from {{DocumentType}} nodes for compatibility
reasons. If these additions are deemed compatible enough in the future, they could be
reinstated.

<pre class=idl>
[NoInterfaceObject,
 Exposed=Window]
interface NonDocumentTypeChildNode {
  readonly attribute Element? previousElementSibling;
  readonly attribute Element? nextElementSibling;
};
Element implements NonDocumentTypeChildNode;
CharacterData implements NonDocumentTypeChildNode;
</pre>

<dl class=domintro>
 <dt><code><var>element</var> = <var>node</var> . {{previousElementSibling}}</code>
 <dd>Returns the first
 <a>preceding</a>
 <a>sibling</a> that
 is an <a>element</a>, and null otherwise.

 <dt><code><var>element</var> = <var>node</var> . {{nextElementSibling}}</code>
 <dd>Returns the first
 <a>following</a>
 <a>sibling</a> that
 is an <a>element</a>, and null otherwise.
</dl>

The <dfn attribute for="NonDocumentTypeChildNode">previousElementSibling</dfn>
attribute must return the first <a>preceding</a> <a>sibling</a> that is an <a>element</a>,
and null otherwise.

The <dfn attribute for=NonDocumentTypeChildNode>nextElementSibling</dfn>
attribute must return the first <a>following</a> <a>sibling</a> that is an <a>element</a>,
and null otherwise.


<h4 id='interface-childnode'>
Interface {{ChildNode}}</h4>

<pre class=idl>
[NoInterfaceObject,
 Exposed=Window]
interface ChildNode {
  [Unscopeable] void before((Node or DOMString)... nodes);
  [Unscopeable] void after((Node or DOMString)... nodes);
  [Unscopeable] void replaceWith((Node or DOMString)... nodes);
  [Unscopeable] void remove();
};
DocumentType implements ChildNode;
Element implements ChildNode;
CharacterData implements ChildNode;
</pre>

<dl class=domintro>
 <dt><code><var>node</var> . {{before(<var>nodes</var>)}}</code>
 <dd>
  Inserts <var>nodes</var> just before <var>node</var>,
  while replacing strings in <var>nodes</var> with equivalent
  {{Text}} <a>nodes</a>.

  <a>Throws</a> a
  {{HierarchyRequestError}} if the constraints of the
  <a>node tree</a> are violated.

 <dt><code><var>node</var> . {{after(<var>nodes</var>)}}</code>
 <dd>
  Inserts <var>nodes</var> just after <var>node</var>,
  while replacing strings in <var>nodes</var> with equivalent
  {{Text}} <a>nodes</a>.

  <a>Throws</a> a
  {{HierarchyRequestError}} if the constraints of the
  <a>node tree</a> are violated.

 <dt><code><var>node</var> . {{replaceWith(<var>nodes</var>)}}</code>
 <dd>
  Replaces <var>node</var> with <var>nodes</var>, while
  replacing strings in <var>nodes</var> with equivalent
  {{Text}} <a>nodes</a>.

  <a>Throws</a> a
  {{HierarchyRequestError}} if the constraints of the
  <a>node tree</a> are violated.

 <dt><code><var>node</var> . {{ChildNode/remove()}}</code>
 <dd>Removes <var>node</var>.
</dl>

The
<dfn method for=ChildNode>before(<var>nodes</var>)</dfn>
method must run these steps:

<ol>
 <li>If the <a>context object</a> does not have a
 <a>parent</a>, terminate these steps.

 <li>Run the <a>mutation method macro</a>.

 <li><a>Pre-insert</a>
 <var>node</var> into the <a>context object</a>'s
 <a>parent</a> before the
 <a>context object</a>.
</ol>

The
<dfn method for=ChildNode>after(<var>nodes</var>)</dfn>
method must run these steps:

<ol>
 <li>If the <a>context object</a> does not have a
 <a>parent</a>, terminate these steps.

 <li>Run the <a>mutation method macro</a>.

 <li><a>Pre-insert</a>
 <var>node</var> into the <a>context object</a>'s
 <a>parent</a> before the
 <a>context object</a>'s
 <a>next sibling</a>.
</ol>

The
<dfn method for=ChildNode>replaceWith(<var>nodes</var>)</dfn>
method must run these steps:

<ol>
 <li>If the <a>context object</a> does not have a
 <a>parent</a>, terminate these steps.

 <li>Run the <a>mutation method macro</a>.

 <li><a>Replace</a> the
 <a>context object</a> with <var>node</var> within the
 <a>context object</a>'s
 <a>parent</a>.
</ol>

The
<dfn method for=ChildNode>remove()</dfn>
method must run these steps:

<ol>
 <li>If the <a>context object</a> does not have a
 <a>parent</a>, terminate these steps.

 <li><a>Remove</a> the
 <a>context object</a> from the
 <a>context object</a>'s
 <a>parent</a>.
</ol>


<h4 id='element-collections'>
Collections: {{Elements}}</h4>

<pre class='idl' data-no-idl>
class Elements extends Array {
  Element? query(DOMString relativeSelectors);
  Elements queryAll(DOMString relativeSelectors);
};
</pre>

<div class=XXX>
IDL bugs: <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20020">
Array subclassing</a> and <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=23225">class, not interface</a>.

{{Elements}} is an ES6-style subclass of {{Array}} with two
additional methods. It's the new {{NodeList}} / {{HTMLCollection}}.
</div>

<dl class=domintro>
 <dt><code><var>elements</var> . {{query(<var>relativeSelectors</var>)}}</code>
 <dd>
  Returns the first <a>element</a> that is a
  <a>descendant</a> of <var>elements</var> that
  matches <var>relativeSelectors</var>.

 <dt><code><var>elements</var> . {{queryAll(<var>relativeSelectors</var>)}}</code>
 <dd>
  Returns all <a>element</a>
  <a>descendants</a> of <var>elements</var> that
  match <var>relativeSelectors</var>.
</dl>

The
<dfn method for=Elements>query(<var>relativeSelectors</var>)</dfn>
method must return the first result of running
<a>match a relative selectors string</a> <var>relativeSelectors</var>
against the <a>context object</a>, and null if the result is an empty list.

The
<dfn method for=Elements>queryAll(<var>relativeSelectors</var>)</dfn>
method must return the result of running <code class='lang-javascript'>this.constructor</code> with the
result of running <a>match a relative selectors string</a>
<var>relativeSelectors</var> against the <a>context object</a>.


<h4 id='old-style-collections'>
Old-style collections: {{NodeList}} and {{HTMLCollection}}</h4>

A <dfn id=concept-collection>collection</dfn> is an object that
represents a lists of DOM nodes. A
<a>collection</a> can be either
<dfn id=concept-collection-live lt="live collection" local-lt="live">live</dfn> or
<dfn id=concept-collection-static lt="static collection">static</dfn>. Unless otherwise stated,
a <a>collection</a> must be <a>live</a>.

If a <a>collection</a> is <a>live</a>, then the attributes and methods
on that object must operate on the actual underlying data, not a snapshot of
the data.

When a <a>collection</a> is created, a
filter and a root are associated with it.

The <a>collection</a> then
<dfn lt="represented by the collection">represents</dfn> a view of the
subtree rooted at the <a>collection's</a>
root, containing only nodes that match the given filter. The view is linear.
In the absence of specific requirements to the contrary, the nodes within
the <a>collection</a> must be sorted in
<a>tree order</a>.


<h5 id='interface-nodelist'>
Interface {{NodeList}}</h5>

A {{NodeList}} object is a
<a>collection</a> of
<a>nodes</a>.

<pre class=idl>
[Exposed=Window]
interface NodeList {
  getter Node? item(unsigned long index);
  readonly attribute unsigned long length;
  iterable&lt;Node>;
};
</pre>

<dl class=domintro>
 <dt><var>collection</var> . {{NodeList/length}}</code>
 <dd>
  Returns the number of <a>nodes</a> in the
  <a>collection</a>.

 <dt><var>element</var> = <var>collection</var> . {{NodeList/item(<var>index</var>)}}
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd>
  Returns the <a>node</a> with index
  <var>index</var> from the
  <a>collection</a>. The
  <a>nodes</a> are sorted in
  <a>tree order</a>.
</dl>

<div class=impl>

The object's <a>supported property indices</a>
are the numbers in the range zero to one less than the number of nodes
<a>represented by the collection</a>. If there are no such elements, then
there are no <a>supported property indices</a>.

The <dfn attribute for=NodeList>length</dfn> attribute must
return the number of nodes <a>represented by the collection</a>.

The
<dfn method for=NodeList>item(<var>index</var>)</dfn>
method must return the <var>index</var>th
node in the <a>collection</a>. If there is no
<var>index</var>th node in the <a>collection</a>, then the method must return null.

</div>


<h5 id='interface-htmlcollection'>
Interface {{HTMLCollection}}</h5>

<pre class=idl>
[Exposed=Window]
interface HTMLCollection {
  readonly attribute unsigned long length;
  getter Element? item(unsigned long index);
  getter Element? namedItem(DOMString name);
};
</pre>

An {{HTMLCollection}} object is a
<a>collection</a> of
<a>elements</a>.

Note: {{Elements}} is the better solution for representing a
<a>collection</a> of
<a>elements</a>. {{HTMLCollection}} is an historical
artifact we cannot rid the web of.

<dl class=domintro>
 <dt><var>collection</var> . {{HTMLCollection/length}}
 <dd>
  Returns the number of <a>elements</a> in
  the <a>collection</a>.

 <dt><var>element</var> = <var>collection</var> . {{HTMLCollection/item(<var>index</var>)}}
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd>
  Returns the <a>element</a> with index
  <var>index</var> from the <a>collection</a>.
  The <a>elements</a> are sorted in <a>tree order</a>.

 <dt><var>element</var> = <var>collection</var> . {{namedItem(<var>name</var>)}}
 <dt><var>element</var> = <var>collection</var>[<var>name</var>]
 <dd>
  Returns the first <a>element</a> with <a>ID</a> or name <var>name</var>
  from the collection.
</dl>

<div class=impl>

The object's <a>supported property indices</a>
are the numbers in the range zero to one less than the number of nodes
<a>represented by the collection</a>. If there are no such elements, then
there are no <a>supported property indices</a>.

The <dfn attribute for=HTMLCollection>length</dfn> attribute
must return the number of nodes <a>represented by the collection</a>.

The
<dfn method for=HTMLCollection>item(<var>index</var>)</dfn>
method must return the <var>index</var>th
<a>element</a> in the <a>collection</a>. If there is no
<var>index</var>th <a>element</a> in the <a>collection</a>, then the method must return null.

The <a>supported property names</a>, all <a>unenumerable</a>,
are the values from the list returned by these steps:

<ol>
 <li>Let <var>result</var> be an empty list.
 <li>
  For each <var>element</var>
  <a>represented by the collection</a>, in
  <a>tree order</a>, run these substeps:
  <ol>
   <li>If <var>element</var> has an
   <a>ID</a> which is neither the empty string nor is
   in <var>result</var>, append <var>element</var>'s
   <a>ID</a> to <var>result</var>.

   <li>If <var>element</var> is in the <a>HTML namespace</a>
   and <a lt="has an attribute">has</a> a
   <a lt="named attribute"><code>name</code> attribute</a>
   whose <a for=Attr>value</a> is neither the
   empty string nor is in <var>result</var>, append
   <var>element</var>'s
   <a lt="named attribute"><code>name</code> attribute</a>
   <a for=Attr>value</a> to <var>result</var>.
  </ol>
 <li>Return <var>result</var>.
</ol>

The
<dfn method for=HTMLCollection>namedItem(<var>key</var>)</dfn>
method must run these steps:
<ol>
 <li>If <var>key</var> is the empty string, return null.
 <li>
  Return the first <a>element</a> in the
  <a>collection</a> for which at least one of
  the following is true:
  <ul>
   <li>it has an <a>ID</a> which is <var>key</var>.
   <li>it <a lt="has an attribute">has</a> a
   <a lt="named attribute"><code>name</code> attribute</a>
   whose <a for=Attr>value</a> is
   <var>key</var>;
  </ul>
  or null if there is no such <a>element</a>.
</ol>

</div>



<h3 id='mutation-observers'>
Mutation observers</h3>

Each
<a>unit of related similar-origin browsing contexts</a> has a
<dfn>mutation observer compound microtask queued flag</dfn> and an associated list of
{{MutationObserver}} objects which is initially empty.
[[!HTML]]

To <dfn>queue a mutation observer compound microtask</dfn>, run these steps:

<ol>
 <li>If <a>mutation observer compound microtask queued flag</a> is set, terminate
 these steps.

 <li>Set <a>mutation observer compound microtask queued flag</a>.

 <li><a lt="queue a microtask">Queue</a> a
 <a>compound microtask</a> to
 <a>notify mutation observers</a>.
</ol>

To <dfn>notify mutation observers</dfn>, run these steps:

<ol>
 <li>Unset <a>mutation observer compound microtask queued flag</a>.

 <li>Let <var>notify list</var> be a copy of
 <a>unit of related similar-origin browsing contexts</a>'s
 list of {{MutationObserver}} objects.

 <li>
  For each {{MutationObserver}} object <var>mo</var> in <var>notify list</var>,
  <a>execute a compound microtask subtask</a> to run these steps: [[!HTML]]

  <ol>
   <li>Let <var>queue</var> be a copy of <var>mo</var>'s <a>record queue</a>.

   <li>Empty <var>mo</var>'s <a>record queue</a>.

   <li>Remove all <a>transient registered observers</a>
   whose <b>observer</b> is <var>mo</var>.

   <li>If <var>queue</var> is non-empty, call
   <var>mo</var>'s <a lt="MO callback">callback</a>
   with <var>queue</var> as first argument, and
   <var>mo</var> (itself) as second argument and
   <a>callback this value</a>. If this throws an exception,
   <a>report the exception</a>.
  </ol>
</ol>

<hr>

Each <a>node</a> has an associated list of
<a>registered observers</a>.
<!-- XXX also mention this in the {{Node}} section non-normatively? -->

A <dfn>registered observer</dfn> consists of an <b>observer</b> (a
{{MutationObserver}} object) and <b>options</b> (a
{{MutationObserverInit}} dictionary). A
<dfn>transient registered observer</dfn> is a specific type of
<a>registered observer</a> that has a <b>source</b> which is a
<a>registered observer</a>.


<h4 id='interface-mutationobserver'>
Interface {{MutationObserver}}</h4>

<pre class="idl">
[Constructor(MutationCallback callback)]
interface MutationObserver {
  void observe(Node target, MutationObserverInit options);
  void disconnect();
  sequence&lt;MutationRecord> takeRecords();
};

callback MutationCallback = void (sequence&lt;MutationRecord> mutations, MutationObserver observer);

dictionary MutationObserverInit {
  boolean childList = false;
  boolean attributes;
  boolean characterData;
  boolean subtree = false;
  boolean attributeOldValue;
  boolean characterDataOldValue;
  sequence&lt;DOMString> attributeFilter;
};
</pre>

A {{MutationObserver}} object can be used to observe mutations
to the <a>tree</a> of
<a>nodes</a>.

Each {{MutationObserver}} object has these associated concepts:
<ul>
 <li>A <dfn lt="MO callback" id=concept-MO-callback>callback</dfn> set on creation.
 <li>A list of <a>nodes</a> on which it is a <a>registered observer</a>'s <b>observer</b> that is initially empty.
 <li>A list of {{MutationRecord}} objects called the
 <dfn id=concept-MO-queue>record queue</dfn> that is initially empty.
</ul>

<dl class=domintro>
 <dt><code><var>observer</var> = new {{MutationObserver(<var>callback</var>)}}</code>
 <dd>Constructs a {{MutationObserver}} object and sets its
 <a lt="MO callback">callback</a> to
 <var>callback</var>. The <var>callback</var> is invoked with a
 list of {{MutationRecord}} objects as first argument and the
 constructed {{MutationObserver}} object as second argument. It is
 invoked after <a>nodes</a> registered with the
 {{MutationObserver/observe()}} method, are
 mutated.

 <dt><code><var>observer</var> . {{observe(<var>target</var>, <var>options</var>)}}</code>
 <dd>
  Instructs the user agent to observe a given <var>target</var>
  (a <a>node</a>) and report any mutations based on
  the criteria given by <var>options</var> (an object).

  The <var>options</var> argument allows for setting mutation
  observation options via object members. These are the object members that
  can be used:

  <dl>
   <dt>{{MutationObserverInit/childList}}
   <dd>Set to true if mutations to <var>target</var>'s <a>children</a> are to be observed.

   <dt>{{MutationObserverInit/attributes}}
   <dd>Set to true if mutations to <var>target</var>'s
   <a>attributes</a> are to be observed. Can be omitted if
   {{MutationObserverInit/attributeOldValue}} and/or
   {{MutationObserverInit/attributeFilter}} is
   specified.

   <dt>{{MutationObserverInit/characterData}}
   <dd>Set to true if mutations to <var>target</var>'s
   <a>data</a> are to be observed. Can be omitted if
   {{MutationObserverInit/characterDataOldValue}}
   is specified.

   <dt>{{MutationObserverInit/subtree}}
   <dd>Set to true if mutations to not just <var>target</var>, but
   also <var>target</var>'s
   <a>descendants</a> are to be
   observed.

   <dt>{{MutationObserverInit/attributeOldValue}}
   <dd>Set to true if
   {{MutationObserverInit/attributes}} is true or omitted
   and <var>target</var>'s
   <a>attribute</a>
   <a for=Attr>value</a> before the mutation
   needs to be recorded.

   <dt>{{MutationObserverInit/characterDataOldValue}}
   <dd>Set to true if
   {{MutationObserverInit/characterData}}
   is set to true or omitted and <var>target</var>'s
   <a>data</a> before the mutation
   needs to be recorded.

   <dt>{{MutationObserverInit/attributeFilter}}
   <dd>Set to a list of <a>attribute</a>
   <a for=Attr>local names</a> (without <a for=Attr>namespace</a>) if not all
   <a>attribute</a> mutations need to be
   observed and {{MutationObserverInit/attributes}} is true
   or omitted.
  </dl>

 <dt><code><var>observer</var> . {{disconnect()}}</code>
 <dd>Stops <var>observer</var> from observing any mutations.
 Until the {{observe()}} method
 is used again, <var>observer</var>'s
 <a lt="MO callback">callback</a> will not be invoked.

 <dt><code><var>observer</var> . {{takeRecords()}}</code>
 <dd>Empties the <a>record queue</a> and
 returns what was in there.
</dl>

The
<dfn constructor for=MutationObserver>MutationObserver(<var>callback</var>)</dfn>
constructor must create a new {{MutationObserver}} object with
<a lt="MO callback">callback</a> set to <var>callback</var>,
append it to the
<a>unit of related similar-origin browsing contexts</a>'s list
of {{MutationObserver}} objects, and then return it.

The
<dfn method for=MutationObserver>observe(<var>target</var>, <var>options</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>If either <var>options</var>'
 {{MutationObserverInit/attributeOldValue}} or
 {{MutationObserverInit/attributeFilter}} is present
 and <var>options</var>'
 {{MutationObserverInit/attributes}} is omitted, set
 <var>options</var>'
 {{MutationObserverInit/attributes}} to true.

 <li>If <var>options</var>'
 {{MutationObserverInit/characterDataOldValue}}
 is present and <var>options</var>'
 {{MutationObserverInit/characterData}} is omitted, set
 <var>options</var>'
 {{MutationObserverInit/characterData}} to true.

 <li>If none of <var>options</var>'
 {{MutationObserverInit/childList}}
 {{MutationObserverInit/attributes}}, and
 {{MutationObserverInit/characterData}} is true,
 <a>throw</a> a <code>TypeError</code>.

 <li>If <var>options</var>'
 {{MutationObserverInit/attributeOldValue}} is true
 and <var>options</var>'
 {{MutationObserverInit/attributes}} is false,
 <a>throw</a> a <code>TypeError</code>.

 <li>If <var>options</var>'
 {{MutationObserverInit/attributeFilter}} is present
 and <var>options</var>'
 {{MutationObserverInit/attributes}} is false,
 <a>throw</a> a <code>TypeError</code>.

 <li>If <var>options</var>'
 {{MutationObserverInit/characterDataOldValue}}
 is true and <var>options</var>'
 {{MutationObserverInit/characterData}} is false,
 <a>throw</a> a <code>TypeError</code>.

 <li>
  For each <a>registered observer</a> <var>registered</var> in
  <var>target</var>'s list of
  <a>registered observers</a> whose <b>observer</b> is
  the <a>context object</a>:

  <ol>
   <li>Remove all
   <a>transient registered observers</a> whose
   <b>source</b> is <var>registered</var>.

   <li>Replace <var>registered</var>'s <b>options</b> with
   <var>options</var>.
  </ol>

 <li>Otherwise, add a new <a>registered observer</a> to
 <var>target</var>'s list of
 <a>registered observers</a> with the
 <a>context object</a> as the <b>observer</b> and <var>options</var> as the <b>options</b>,
 and add <var>target</var> to <a>context object</a>'s list of <a>nodes</a> on which it is registered.
</ol>

The
<dfn method for=MutationObserver>disconnect()</dfn>
method must, for each <a>node</a>
<var>node</var> in the <a>context object</a>'s list of
<a>nodes</a>, remove any
<a>registered observer</a> on <var>node</var>
for which the <a>context object</a> is the <b>observer</b>, and also
empty <a>context object</a>'s
<a>record queue</a>.

The
<dfn method for=MutationObserver>takeRecords()</dfn>
method must return a copy of the
<a>record queue</a> and then empty the
<a>record queue</a>.


<h4 id='queueing-a-mutation-record'>
Queuing a mutation record</h4>

To <dfn>queue a mutation record</dfn> of <var>type</var> for
<var>target</var> with one or more of (depends on
<var>type</var>) name <var>name</var>, namespace
<var>namespace</var>, oldValue <var>oldValue</var>, addedNodes
<var>addedNodes</var>, removedNodes <var>removedNodes</var>,
previousSibling <var>previousSibling</var>, and nextSibling
<var>nextSibling</var>, run these steps:

<ol>
 <li>Let <var>interested observers</var> be an initially empty set
 of {{MutationObserver}} objects optionally paired with a string.

 <li>Let <var>nodes</var> be the <a>inclusive ancestors</a> of <var>target</var>.

 <li>
  Then, for each <var>node</var> in <var>nodes</var>, and
  then for each <var>registered observer</var> (with
  <var>registered observer</var>'s <b>options</b> as
  <var>options</var>) in <var>node</var>'s list of
  <a>registered observers</a>:

  <ol>
   <li>If <var>node</var> is not <var>target</var> and
   <var>options</var>'s <code>subtree</code> is false, continue.

   <li>If <var>type</var> is "<code>attributes</code>" and
   <var>options</var>'s <code>attributes</code> is not true, continue.
   <!--not true==false||omitted-->

   <li>If <var>type</var> is "<code>attributes</code>",
   <var>options</var>'s <code>attributeFilter</code> is present, and either
   <var>options</var>'s <code>attributeFilter</code> does not contain
   <var>name</var> or <var>namespace</var> is non-null, continue.

   <li>If <var>type</var> is "<code>characterData</code>" and
   <var>options</var>'s <code>characterData</code> is not true, continue.
   <!--not true==false||omitted-->

   <li>If <var>type</var> is "<code>childList</code>" and
   <var>options</var>'s <code>childList</code> is false, continue.

   <li>If <var>registered observer</var>'s <b>observer</b> is
   not in <var>interested observers</var>, append
   <var>registered observer</var>'s <b>observer</b> to
   <var>interested observers</var>.

   <li>If either <var>type</var> is "<code>attributes</code>"
   and <var>options</var>'s <code>attributeOldValue</code> is true, or
   <var>type</var> is "<code>characterData</code>" and
   <var>options</var>'s <code>characterDataOldValue</code> is true,
   set the paired string of
   <var>registered observer</var>'s <b>observer</b> in
   <var>interested observers</var> to <var>oldValue</var>.
  </ol>

 <li>
  Then, for each <var>observer</var> in
  <var>interested observers</var>:

  <ol>
   <li>Let <var>record</var> be a new {{MutationRecord}}
   object with its {{MutationRecord/type}} set to
   <var>type</var> and
   {{MutationRecord/target}} set to
   <var>target</var>.

   <li>If <var>name</var> and <var>namespace</var> are given,
   set <var>record</var>'s
   {{MutationRecord/attributeName}} to
   <var>name</var>, and <var>record</var>'s
   {{MutationRecord/attributeNamespace}}
   to <var>namespace</var>.

   <li>If <var>addedNodes</var> is given, set <var>record</var>'s
   {{MutationRecord/addedNodes}} to
   <var>addedNodes</var>.

   <li>If <var>removedNodes</var> is given, set <var>record</var>'s
   {{MutationRecord/removedNodes}} to
   <var>removedNodes</var>,

   <li>If <var>previousSibling</var> is given, set <var>record</var>'s
   {{MutationRecord/previousSibling}} to
   <var>previousSibling</var>.

   <li>If <var>nextSibling</var> is given, set <var>record</var>'s
   {{MutationRecord/nextSibling}} to
   <var>nextSibling</var>.

   <li>If <var>observer</var> has a paired string,
   set <var>record</var>'s {{MutationRecord/oldValue}}
   to <var>observer</var>'s paired string.

   <li>Append <var>record</var> to <var>observer</var>'s
   <a>record queue</a>.
  </ol>

 <li><a>Queue a mutation observer compound microtask</a>.
</ol>


<h4 id='interface-mutationrecord'>
Interface {{MutationRecord}}</h4>

<pre class=idl>
[Exposed=Window]
interface MutationRecord {
  readonly attribute DOMString type;
  readonly attribute Node target;
  [SameObject] readonly attribute NodeList addedNodes;
  [SameObject] readonly attribute NodeList removedNodes;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;
  readonly attribute DOMString? attributeName;
  readonly attribute DOMString? attributeNamespace;
  readonly attribute DOMString? oldValue;
};
</pre>

<dl class=domintro>
 <dt><code><var>record</var> . {{MutationRecord/type}}</code>
 <dd>Returns "<code>attributes</code>" if it was an
 <a>attribute</a> mutation.
 "<code>characterData</code>" if it was a mutation to a
 {{CharacterData}} <a>node</a>. And
 "<code>childList</code>" if it was a mutation to the
 <a>tree</a> of
 <a>nodes</a>.

 <dt><code><var>record</var> . {{MutationRecord/target}}</code>
 <dd>Returns the <a>node</a> the mutation
 affected, depending on the {{MutationRecord/type}}.
 For "<code>attributes</code>", it is the
 <a>element</a> whose
 <a>attribute</a> changed. For
 "<code>characterData</code>", it is the {{CharacterData}}
 <a>node</a>. For "<code>childList</code>",
 it is the  <a>node</a> whose
 <a>children</a> changed.

 <dt><code><var>record</var> . {{MutationRecord/addedNodes}}</code>
 <dt><code><var>record</var> . {{MutationRecord/removedNodes}}</code>
 <dd>Return the <a>nodes</a> added and removed
 respectively.

 <dt><code><var>record</var> . {{MutationRecord/previousSibling}}</code>
 <dt><code><var>record</var> . {{MutationRecord/nextSibling}}</code>
 <dd>Return the <a lt="previous sibling">previous</a> and <a>next sibling</a> respectively
 of the added or removed <a>nodes</a>, and null otherwise.

 <dt><code><var>record</var> . {{MutationRecord/attributeName}}</code>
 <dd>Returns the
 <a for=Attr>local name</a> of the
 changed <a>attribute</a>, and null otherwise.

 <dt><code><var>record</var> . {{MutationRecord/attributeNamespace}}</code>
 <dd>Returns the <a for=Attr>namespace</a> of the
 changed <a>attribute</a>, and null otherwise.

 <dt><code><var>record</var> . {{MutationRecord/oldValue}}</code>
 <dd>The return value depends on
 {{MutationRecord/type}}. For
 "<code>attributes</code>", it is the
 <a for=Attr>value</a> of the
 changed <a>attribute</a> before the change.
 For "<code>characterData</code>", it is the
 <a>data</a> of the changed
 <a>node</a> before the change. For
 "<code>childList</code>", it is null.
</dl>

The <dfn attribute for=MutationRecord>type</dfn> and
<dfn attribute for=MutationRecord>target</dfn>
attributes must return the values they were initialized to.

The
Record<dfn attribute for="MutationRecord">addedNodes</dfn> and
<dfn attribute for="MutationRecord">removedNodes</dfn>
attributes must return the values they were initialized to. Unless stated
otherwise, when a {{MutationRecord}} object is created, they must
both be initialized to an empty {{NodeList}}.

The
<dfn attribute for="MutationRecord">previousSibling</dfn>,
<dfn attribute for="MutationRecord">nextSibling</dfn>,
<dfn attribute for="MutationRecord">attributeName</dfn>,
<dfn attribute for="MutationRecord">attributeNamespace</dfn>, and
<dfn attribute for="MutationRecord">oldValue</dfn>
attributes must return the values they were initialized to. Unless stated
otherwise, when a {{MutationRecord}} object is created, they must
be initialized to null.

<h4 id='garbage-collection'>
Garbage collection</h4>

<a>Nodes</a> have a strong reference to
<a>registered observers</a> in their
list of <a>registered observers</a>.

<a>Registered observers</a> in a
<a>node</a>'s list of
<a>registered observers</a> have a weak
reference to the <a>node</a>.


<h3 id='interface-node'>
Interface {{Node}}</h3>

<pre class=idl>
[Exposed=Window]
interface Node : EventTarget {
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2; // historical
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4; // historical
  const unsigned short ENTITY_REFERENCE_NODE = 5; // historical
  const unsigned short ENTITY_NODE = 6; // historical
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12; // historical
  readonly attribute unsigned short nodeType;
  readonly attribute DOMString nodeName;

  readonly attribute DOMString? baseURI;

  readonly attribute Document? ownerDocument;
  readonly attribute Node? parentNode;
  readonly attribute Element? parentElement;
  boolean hasChildNodes();
  [SameObject] readonly attribute NodeList childNodes;
  readonly attribute Node? firstChild;
  readonly attribute Node? lastChild;
  readonly attribute Node? previousSibling;
  readonly attribute Node? nextSibling;

           attribute DOMString? nodeValue;
           attribute DOMString? textContent;
  void normalize();

  [NewObject] Node cloneNode(optional boolean deep = false);
  boolean isEqualNode(Node? node);

  const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
  const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
  const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
  const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
  const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
  const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
  unsigned short compareDocumentPosition(Node other);
  boolean contains(Node? other);

  DOMString? lookupPrefix(DOMString? namespace);
  DOMString? lookupNamespaceURI(DOMString? prefix);
  boolean isDefaultNamespace(DOMString? namespace);

  Node insertBefore(Node node, Node? child);
  Node appendChild(Node node);
  Node replaceChild(Node node, Node child);
  Node removeChild(Node child);
};
</pre>

Note: {{Node}} is an abstract interface and does not exist as <a>node</a>.
It is used by all <a>nodes</a>
({{Document}}, {{DocumentFragment}}, {{DocumentType}}, {{Element}}, {{Text}}, {{ProcessingInstruction}}, and {{Comment}}).

Each <a>node</a> has an associated
<dfn id=concept-node-document>node document</dfn>, set upon creation,
that is a <a>document</a>.

Note: A <a>node</a>'s
<a>node document</a> can be changed by
the <a>adopt</a> algorithm.

Each <a>node</a> also has an associated
<dfn id=concept-node-base-url>base URL</dfn>.

Note: Other specifications define the value of the
<a>base URL</a> and its observable
behavior. This specification solely defines the concept and the
{{Node/baseURI}} attribute.

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/nodeType}}</code>
 <dd>
  Returns the type of <var>node</var>, represented by a number from the following list:

  <dl>
   <dt><code>{{Node}} . {{Node/ELEMENT_NODE}}</code> (1)
   <dd><var>node</var> is an
   <a>element</a>.

   <dt><code>{{Node}} . {{Node/TEXT_NODE}}</code> (3)
   <dd><var>node</var> is a {{Text}}
   <a>node</a>.

   <dt><code>{{Node}} . {{Node/PROCESSING_INSTRUCTION_NODE}}</code> (7)
   <dd><var>node</var> is a {{ProcessingInstruction}}
   <a>node</a>.

   <dt><code>{{Node}} . {{Node/COMMENT_NODE}}</code> (8)
   <dd><var>node</var> is a {{Comment}}
   <a>node</a>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_NODE}}</code> (9)
   <dd><var>node</var> is a
   <a>document</a>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_TYPE_NODE}}</code> (10)
   <dd><var>node</var> is a
   <a>doctype</a>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_FRAGMENT_NODE}}</code> (11)
   <dd><var>node</var> is a {{DocumentFragment}}
   <a>node</a>.
  </dl>

 <dt><code><var>node</var> . {{Node/nodeName}}</code>
 <dd>
  Returns a string appropriate for the type of <var>node</var>, as
  follows:

  <dl>
   <dt>{{Element}}
   <dd>Its {{Element/tagName}} attribute value.

   <dt>{{Text}}
   <dd>"<code>#text</code>".

   <dt>{{ProcessingInstruction}}
   <dd>Its <a lt="PI target">target</a>.

   <dt>{{Comment}}
   <dd>"<code>#comment</code>".

   <dt>{{Document}}
   <dd>"<code>#document</code>".

   <dt>{{DocumentType}}
   <dd>Its <a lt="doctype name">name</a>.

   <dt>{{DocumentFragment}}
   <dd>"<code>#document-fragment</code>".
  </dl>
</dl>

The <dfn attribute for="Node">nodeType</dfn> attribute
must return the type of the node, which must be one of the following:

<ul>
 <li><dfn const for="Node">ELEMENT_NODE</dfn> (1);

 <!--AttrExodus
 <li><dfn const for="Node">ATTRIBUTE_NODE</dfn> (2, historical);
 -->

 <li><dfn const for="Node">TEXT_NODE</dfn> (3);

 <!-- XXX still questionable
 <li><dfn const for="Node">CDATA_SECTION_NODE</dfn> (4, historical);
 -->

 <li><dfn const for="Node">PROCESSING_INSTRUCTION_NODE</dfn> (7);

 <li><dfn const for="Node">COMMENT_NODE</dfn> (8);

 <li><dfn const for="Node">DOCUMENT_NODE</dfn> (9);

 <li><dfn const for="Node">DOCUMENT_TYPE_NODE</dfn> (10);

 <li><dfn const for="Node">DOCUMENT_FRAGMENT_NODE</dfn> (11).
</ul>


<!-- NodeExodus
<hr>

The <dfn attribute for="Node">namespaceURI</dfn> attribute must return the namespace that is associated with the node, if there is one and it's not the empty string, and null otherwise.

The <dfn attribute for="Node">prefix</dfn> attribute must return the prefix that is associated with the node, if there is one and it's not the empty string, and null otherwise.
<!- - support setting? - - On setting, it must run these steps:

<ol>
 <li>Let <var>prefix</var> be the value being assigned.
 <li>
  If <var>prefix</var> is not null, run these substeps:
  <ol>
   <li>If <var>prefix</var> does not match the
   <code><a type>Name</a></code> production in XML,
   <a>throw</a> an
   {{InvalidCharacterError}} exception.
   <li>If <var>prefix</var> does not match the <a type>NCName</a> production in Namespaces in XML, <a>throw</a> a
   {{NamespaceError}} exception.
  </ol>
 <li>Actually this does not match any browser. Let's try to drop it instead.
</ol>- ->

The <dfn attribute for="Node">localName</dfn> attribute
must return the local name that is associated with the node, if it has one,
and null otherwise.-->

The <dfn attribute for="Node">nodeName</dfn> attribute
must return the following, depending on the <a>context object</a>:

<dl class=switch>
 <dt>{{Element}}
 <dd>Its {{Element/tagName}} attribute value.

 <!--AttrExodus
 <dt>{{Attr}}
 <dd>The <a>context object</a>'s
 {{Attr/name}} attribute.
 -->

 <dt>{{Text}}
 <dd>"<code>#text</code>".

 <dt>{{ProcessingInstruction}}
 <dd>Its <a lt="PI target">target</a>.

 <dt>{{Comment}}
 <dd>"<code>#comment</code>".

 <dt>{{Document}}
 <dd>"<code>#document</code>".

 <dt>{{DocumentType}}
 <dd>Its <a lt="doctype name">name</a>.

 <dt>{{DocumentFragment}}
 <dd>"<code>#document-fragment</code>".
</dl>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/baseURI}}</code>
 <dd>Returns the <a>base URL</a>.
</dl>

The <dfn attribute for="Node">baseURI</dfn> attribute must return the associated <a>base URL</a>.

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/ownerDocument}}</code>
 <dd>
  Returns the <a>node document</a>.
  Returns null for <a>documents</a>.

 <dt><code><var>node</var> . {{Node/parentNode}}</code>
 <dd>Returns the <a>parent</a>.

 <dt><code><var>node</var> . {{Node/parentElement}}</code>
 <dd>Returns the <a>parent element</a>.

 <dt><code><var>node</var> . {{Node/hasChildNodes()}}</code>
 <dd>Returns whether <var>node</var> has
 <a>children</a>.

 <dt><code><var>node</var> . {{Node/childNodes}}</code>
 <dd>Returns the <a>children</a>.

 <dt><code><var>node</var> . {{Node/firstChild}}</code>
 <dd>Returns the <a>first child</a>.

 <dt><code><var>node</var> . {{Node/lastChild}}</code>
 <dd>Returns the <a>last child</a>.

 <dt><code><var>node</var> . {{Node/previousSibling}}</code>
 <dd>Returns the
 <a>previous sibling</a>.

 <dt><code><var>node</var> . {{Node/nextSibling}}</code>
 <dd>Returns the
 <a>next sibling</a>.
</dl>

<div class=impl>

The <dfn attribute for="Node">ownerDocument</dfn>
attribute must run these steps:
<ol>
 <li>If the <a>context object</a> is a
 <a>document</a>, return null.

 <li>Return the <a>node document</a>.
</ol>

<div class=note>
The <a>node document</a> of a
<a>document</a> is that
<a>document</a> itself.
All <a>nodes</a> have a
<a>document</a> at all times.
</div>

The <dfn attribute for="Node">parentNode</dfn>
attribute must return the <a>parent</a>.
<!-- AttrExodus
<li>If the <a>context object</a> is an {{Attr}} node,
return null.
-->

The <dfn attribute for="Node">parentElement</dfn>
attribute must return the <a>parent element</a>.

The <dfn method for="Node">hasChildNodes()</dfn>
method must return true if the <a>context object</a> has
<a>children</a>, and false otherwise.

The <dfn attribute for="Node">childNodes</dfn>
attribute must return a {{NodeList}} rooted at the
<a>context object</a> matching only
<a>children</a>.

The <dfn attribute for="Node">firstChild</dfn>
attribute must return the
<a>first child</a>.

The <dfn attribute for="Node">lastChild</dfn> attribute must return the <a>last child</a>.

The
<dfn attribute for="Node">previousSibling</dfn>
attribute must return the
<a>previous sibling</a>.
<!-- AttrExodus
 <li>If the <a>context object</a> is an {{Attr}} node,
 return null.
-->

The <dfn attribute for="Node">nextSibling</dfn>
attribute must return the
<a>next sibling</a>.
<!-- AttrExodus
 <li>If the <a>context object</a> is an {{Attr}} node,
 return null.
-->

</div>

<hr>

<!-- TODO: domintro -->

The <dfn attribute for="Node">nodeValue</dfn> attribute
must return the following, depending on the <a>context object</a>:

<dl class=switch>
 <!--AttrExodus <dt>{{Attr}} -->
 <dt>{{Text}}
 <dt>{{Comment}}
 <dt>{{ProcessingInstruction}}
 <dd>The <a>context object</a>'s
 <a>data</a>.

 <dt>Any other node
 <dd>Null.
</dl>

The {{Node/nodeValue}} attribute must,
on setting, if the new value is null, act as if it was the empty string
instead, and then do as described below, depending on the <a>context object</a>:

<dl class=switch>
 <!--AttrExodus <dt>{{Attr}} -->
 <dt>{{Text}}
 <dt>{{Comment}}
 <dt>{{ProcessingInstruction}}
 <dd><a>Replace data</a> with node
 <a>context object</a>, offset 0, count
 {{CharacterData/length}} attribute value, and
 data new value.

 <dt>Any other node
 <dd>Do nothing.
</dl>

The <dfn attribute for="Node">textContent</dfn>
attribute must return the following, depending on the
<a>context object</a>:

<dl class=switch>
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <!--AttrExodus <dt>{{Attr}} -->
 <dd>The concatenation of <a>data</a> of all
 the {{Text}} <a>node</a>
 <a>descendants</a> of the
 <a>context object</a>, in
 <a>tree order</a>.

 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd>The <a>context object</a>'s
 <a>data</a>.

 <dt>Any other node
 <dd>Null.
</dl>

The {{Node/textContent}} attribute must,
on setting, if the new value is null, act as if it was the empty string
instead, and then do as described below, depending on the <a>context object</a>:

<dl class=switch>
 <dt>{{DocumentFragment}}
 <dt>{{Element}}
 <!--AttrExodus <dt>{{Attr}} -->
 <dd>
  <ol>
   <li>Let <var>node</var> be null.

   <li>If new value is not the empty string, set <var>node</var> to
   a new {{Text}} <a>node</a> whose
   <a>data</a> is new value.

   <li><a>Replace all</a> with
   <var>node</var> within the <a>context object</a>.
  </ol>

 <dt>{{Text}}
 <dt>{{ProcessingInstruction}}
 <dt>{{Comment}}
 <dd><a>Replace data</a> with node
 <a>context object</a>, offset 0, count
 {{CharacterData/length}} attribute value, and
 data new value.

 <dt>Any other node
 <dd>Do nothing.
</dl>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{Node/normalize()}}()</code>
 <dd>Removes <a>empty</a>
 {{Text}} <a>nodes</a> and concatenates
 the <a>data</a> of remaining
 <a>contiguous <code>Text</code> nodes</a> into the first of their
 <a>nodes</a>.
</dl>

The <dfn method for="Node">normalize()</dfn> method
must run these steps:

For each {{Text}} <a>node</a>
<a>descendant</a> of the
<a>context object</a>:

<ol>
 <li>Let <var>node</var> be the {{Text}}
 <a>node</a>
 <a>descendant</a>.

 <li>Let <var>length</var> be <var>node</var>'s
 {{CharacterData/length}} attribute value.

 <li>If <var>length</var> is zero,
 <a>remove</a> <var>node</var> and
 continue with the next {{Text}}
 <a>node</a>, if any.

 <li>Let <var>data</var> be the concatenation of the
 <a>data</a> of <var>node</var>'s
 <a>contiguous <code>Text</code> nodes</a> (excluding itself), in
 <a>tree order</a>.

 <li><a>Replace data</a> with node
 <var>node</var>, offset <var>length</var>,
 count 0, and data <var>data</var>.

 <li>Let <var>current node</var> be <var>node</var>'s
 <a>next sibling</a>.

 <li>While <var>current node</var> is a {{Text}} node:

 <ol>
  <li>For each <a>range</a> whose
  <a>start node</a> is
  <var>current node</var>, add <var>length</var> to its
  <a>start offset</a> and set its
  <a>start node</a> to
  <var>node</var>.

  <li>For each <a>range</a> whose
  <a>end node</a> is
  <var>current node</var>, add <var>length</var> to its
  <a>end offset</a> and set its
  <a>end node</a> to
  <var>node</var>.

  <li>For each <a>range</a> whose
  <a>start node</a> is
  <var>current node</var>'s
  <a>parent</a> and
  <a>start offset</a> is
  <var>current node</var>'s
  <a>index</a>, set its
  <a>start node</a> to
  <var>node</var> and its
  <a>start offset</a> to
  <var>length</var>.

  <li>For each <a>range</a> whose
  <a>end node</a> is
  <var>current node</var>'s
  <a>parent</a> and
  <a>end offset</a> is
  <var>current node</var>'s
  <a>index</a>, set its
  <a>end node</a> to
  <var>node</var> and its
  <a>end offset</a> to
  <var>length</var>.

  <li>Add <var>current node</var>'s
  {{CharacterData/length}} attribute value to
  <var>length</var>.

  <li>Set <var>current node</var> to its
  <a>next sibling</a>.
 </ol>

 <li><a>Remove</a>
 <var>node</var>'s
 <a>contiguous <code>Text</code> nodes</a> (excluding itself), in
 <a>tree order</a>.
</ol>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . <a method lt="cloneNode()">cloneNode([<var>deep</var> = false])</a></code>
 <dd>Returns a copy of <var>node</var>. If
 <var>deep</var> is true, the copy also includes the
 <var>node</var>'s <a>descendants</a>.

 <dt><code><var>node</var> . {{Node/isEqualNode(<var>other</var>)}}</code>
 <dd>Returns whether <var>node</var> and <var>other</var>
 have the same properties.
</dl>

<div class=impl>

<a lt="Other applicable specifications">Specifications</a> may define
<dfn id=concept-node-clone-ext>cloning steps</dfn> for all or some
<a>nodes</a>. The algorithm is passed <var>copy</var>,
<var>node</var>, <var>document</var>, and optionally a
<i>clone children flag</i>, as indicated in the
<a lt="clone a node">clone</a> algorithm.

Note: HTML defines
<a>cloning steps</a> for
<{script}> and
<{input}> elements. SVG ought to do the same
for its <{script}> elements, but does not call this out at
the moment.

To <dfn id=concept-node-clone lt="clone a node" local-lt="clone">clone</dfn> a <var>node</var>,
optionally with a <var>document</var> and a <i>clone children flag</i>, run
these steps:
<!-- This algorithm is used by dom-Node-cloneNode, dom-Document-importNode,
dom-Range-extractContents, dom-Range-cloneContents -->

<ol>
 <li>If <var>document</var> is not given, let <var>document</var> be
 <var>node</var>'s <a>node document</a>.

 <li>Let <var>copy</var> be a <a>node</a>
 that implements the same interfaces as <var>node</var>.

 <li>
  If <var>copy</var> is a
  <a>document</a>, set its
  <a>node document</a> and
  <var>document</var> to <var>copy</var>.
  Otherwise, set <var>copy</var>'s
  <a>node document</a> to
  <var>document</var>.

 <li>
  Copy the following from <var>node</var> to <var>copy</var>, depending on
  the type of <var>node</var>:
  <dl class=switch>
   <dt>{{Document}}
   <dd>Its <a lt="document encoding">encoding</a>,
   <a lt="document content type">content type</a>,
   <a lt="document URL">URL</a>, its mode
   (<a>quirks mode</a>,
   <a>limited-quirks mode</a>, or
   <a>no-quirks mode</a>), and its type
   (<a>XML document</a> or <a>HTML document</a>).

   <dt>{{DocumentType}}
   <dd>Its <a lt="doctype name">name</a>,
   <a>public ID</a>, and
   <a>system ID</a>.

   <dt>{{Element}}
   <dd>Its <a for=Element>namespace</a>,
   <a for=Element>namespace prefix</a>,
   <a for=Element>local name</a>, and its
   <a for=Element>attribute list</a>.

   <!--AttrExodus
   <dt>{{Attr}}
   <dd>{{Attr/value}}
   -->

   <dt>{{Text}}
   <dt>{{Comment}}
   <dd>Its <a>data</a>.

   <dt>{{ProcessingInstruction}}
   <dd>Its <a lt="PI target">target</a> and <a>data</a>.

   <dt>Any other node
   <dd>&mdash;
  </dl>

 <li>Run any <a>cloning steps</a>
 defined for <var>node</var> in <a>other applicable specifications</a> and
 pass <var>copy</var>, <var>node</var>, <var>document</var> and the
 <i>clone children flag</i> if set, as parameters.

 <li>If the <i>clone children flag</i> is set,
 <a lt="clone a node">clone</a> all the
 <a>children</a> of <var>node</var> and
 append them to <var>copy</var>, with <var>document</var>
 as specified and the <i>clone children flag</i> being set.

 <li>Return <var>copy</var>.
</ol>

The
<dfn method for="Node">cloneNode(<var>deep</var>)</dfn>
method must return a <a lt="clone a node">clone</a> of the
<a>context object</a>, with the <i>clone children flag</i> set
if <var>deep</var> is true.

A <a>node</a> <var>A</var>
<dfn id=concept-node-equals>equals</dfn> a <a>node</a>
<var>B</var> if all of the following conditions are true:

<ul>
 <li><var>A</var> and <var>B</var>'s
 {{Node/nodeType}} attribute value is identical.
 <li>
  The following are also equal, depending on <var>A</var>:
  <dl class=switch>
   <dt>{{DocumentType}}
   <dd>Its <a lt="doctype name">name</a>,
   <a>public ID</a>, and
   <a>system ID</a>.

   <dt>{{Element}}
   <dd>
    Its <a for=Element>namespace</a>,
    <a for=Element>namespace prefix</a>,
    <a for=Element>local name</a>, and its
    number of <a>attributes</a> in its
    <a for=Element>attribute list</a>.

   <!--AttrExodus
   <dt>{{Attr}}
   <dd>{{Attr/value}}
   -->

   <dt>{{ProcessingInstruction}}
   <dd>Its <a lt="PI target">target</a> and
   <a>data</a>.

   <dt>{{Text}}
   <dt>{{Comment}}
   <dd>Its <a>data</a>.

   <dt>Any other node
   <dd>&mdash;
  </dl>
 <li>If <var>A</var> is an <a>element</a>, each
 <a>attribute</a> in its
 <a for=Element>attribute list</a> has an
 <a>attribute</a> with the same
 <a for=Attr>namespace</a>,
 <a for=Attr>local name</a>, and
 <a for=Attr>value</a> in <var>B</var>'s
 <a for=Element>attribute list</a>.
 <li><var>A</var> and <var>B</var> have the same number of
 <a>children</a>.
 <li>Each <a>child</a> of <var>A</var>
 <a>equals</a> the
 <a>child</a> of <var>B</var> at the identical
 <a>index</a>.
</ul>

The
<dfn method for="Node">isEqualNode(<var>node</var>)</dfn>
method must return true if <var>node</var> is not null and
<a>context object</a> <a>equals</a>
<var>node</var>, and false otherwise.

</div>

<hr>

<dl class=domintro>
 <dt><code><var>node</var> . {{compareDocumentPosition(<var>other</var>)}}</code>
 <dd>
  Returns a bitmask indicating the position of <var>other</var>
  relative to <var>node</var>. These are the bits that can be set:

  <dl>
   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_DISCONNECTED}}</code> (1)
   <dd>Set when <var>node</var> and <var>other</var> are not in the
   same <a>tree</a>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_PRECEDING}}</code> (2)
   <dd>Set when <var>other</var> is
   <a>preceding</a>
   <var>node</var>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_FOLLOWING}}</code> (4)
   <dd>Set when <var>other</var> is
   <a>following</a>
   <var>node</var>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_CONTAINS}}</code> (8)
   <dd>Set when <var>other</var> is an
   <a>ancestor</a> of
   <var>node</var>.

   <dt><code>{{Node}} . {{Node/DOCUMENT_POSITION_CONTAINED_BY}}</code> (16, 10 in hexadecimal)
   <dd>Set when <var>other</var> is a
   <a>descendant</a> of
   <var>node</var>.
  </dl>

 <dt><code><var>node</var> . {{Node/contains(<var>other</var>)}}</code>
 <dd>Returns true if <var>other</var> is an
 <a>inclusive descendant</a>
 of <var>node</var>, and false otherwise.
</dl>

These are the constants
{{compareDocumentPosition()}}
returns as mask:

<ul class="brief">
 <li><dfn const for="Node">DOCUMENT_POSITION_DISCONNECTED</dfn> (1);
 <li><dfn const for="Node">DOCUMENT_POSITION_PRECEDING</dfn> (2);
 <li><dfn const for="Node">DOCUMENT_POSITION_FOLLOWING</dfn> (4);
 <li><dfn const for="Node">DOCUMENT_POSITION_CONTAINS</dfn> (8);
 <li><dfn const for="Node">DOCUMENT_POSITION_CONTAINED_BY</dfn> (16, 10 in hexadecimal);
 <li><dfn const for="Node">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</dfn> (32, 20 in hexadecimal).
</ul>

The <dfn method for=Node>compareDocumentPosition(<var>other</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>reference</var> be the <a>context object</a>.
 <li>If <var>other</var> and <var>reference</var> are the
 same object, return zero.

 <li>
  If <var>other</var> and <var>reference</var> are not
  in the same <a>tree</a>, return the result of
  adding
  {{Node/DOCUMENT_POSITION_DISCONNECTED}},
  {{Node/DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC}},
  and either
  {{Node/DOCUMENT_POSITION_PRECEDING}} or
  {{Node/DOCUMENT_POSITION_FOLLOWING}},
  with the constraint that this is to be consistent, together.

  Note: Whether to return
  {{Node/DOCUMENT_POSITION_PRECEDING}} or
  {{Node/DOCUMENT_POSITION_FOLLOWING}}
  is typically implemented via pointer comparison. In JavaScript
  implementations <code class='lang-javascript'>Math.random()</code> can be used.

 <li>If <var>other</var> is an
 <a>ancestor</a> of
 <var>reference</var>, return the result of adding
 {{Node/DOCUMENT_POSITION_CONTAINS}}
 to
 {{Node/DOCUMENT_POSITION_PRECEDING}}.

 <li>If <var>other</var> is a
 <a>descendant</a> of
 <var>reference</var>, return the result of adding
 {{Node/DOCUMENT_POSITION_CONTAINED_BY}}
 to
 {{Node/DOCUMENT_POSITION_FOLLOWING}}.

 <li>If <var>other</var> is
 <a>preceding</a>
 <var>reference</var> return
 {{Node/DOCUMENT_POSITION_PRECEDING}}.

 <li>Return
 {{Node/DOCUMENT_POSITION_FOLLOWING}}.
</ol>

<!-- AttrExodus compareDocumentPosition() works differently if Attr inherits
     from Node -->

The
<dfn method for="Node">contains(<var>other</var>)</dfn>
method must return true if <var>other</var> is an
<a>inclusive descendant</a> of
the <a>context object</a>, and false otherwise (including when
<var>other</var> is null).

<hr>

<!-- TODO: domintro -->

<!--
 XXX apparently these algorithms might not be quite correct
 https://bugzilla.mozilla.org/show_bug.cgi?id=312019
 https://bugzilla.mozilla.org/show_bug.cgi?id=505178
-->

To <dfn lt="locate a namespace prefix|locating a namespace prefix">locate a namespace prefix</dfn> for an <var>element</var> using
<var>namespace</var> run these steps:

<ol>
 <li>If <var>element</var>'s
 <a for=Element>namespace</a> is
 <var>namespace</var> and its
 <a for=Element>namespace prefix</a> is not
 null, return its
 <a for=Element>namespace prefix</a>.

 <li>If, <var>element</var>
 <a lt="has an attribute">has</a> an
 <a>attribute</a> whose
 <a for=Attr>namespace prefix</a> is
 "<code>xmlns</code>" and
 <a for=Attr>value</a> is
 <var>namespace</var>, then return <var>element</var>'s first
 such <a>attribute</a>'s
 <a for=Attr>local name</a>.

 <li>If <var>element</var>'s <a>parent element</a> is not null,
 return the result of running <a>locate a namespace prefix</a> on that
 <a>element</a> using <var>namespace</var>.
 Otherwise, return null.
</ol>

To <dfn>locate a namespace</dfn> for a <var>node</var> using
<var>prefix</var> depends on <var>node</var>:

<dl class=switch>
 <dt>{{Element}}
 <dd>
  <ol>
   <li>If its <a for=Element>namespace</a> is
   not null and its
   <a for=Element>namespace prefix</a> is
   <var>prefix</var>, return
   <a for=Element>namespace</a>.

   <li>
    If it <a lt="has an attribute">has</a> an
    <a>attribute</a> whose
    <a for=Attr>namespace</a> is the
    <a>XMLNS namespace</a>,
    <a for=Attr>namespace prefix</a>
    is "<code>xmlns</code>" and
    <a for=Attr>local name</a> is
    <var>prefix</var>, or if <var>prefix</var> is null and it
    <a lt="has an attribute">has</a> an
    <a>attribute</a> whose
    <a for=Attr>namespace</a> is the
    <a>XMLNS namespace</a>,
    <a for=Attr>namespace prefix</a>
    is null and <a for=Attr>local name</a>
    is "<code>xmlns</code>":

    <ol>
     <li>Let <var>value</var> be its
     <a for=Attr>value</a> if it is not the empty
     string, and null otherwise.

     <li>Return <var>value</var>.
    </ol>

   <li>If its <a>parent element</a> is null, return null.

   <li>Return the result of running <a>locate a namespace</a> on
   its <a>parent element</a> using <var>prefix</var>.
  </ol>

 <!--AttrExodus {{Attr}} -->
 <dt>{{Document}}
 <dd>
  <ol>
   <li>If its <a>document element</a> is null, return null.

   <li>Return the result of running <a>locate a namespace</a> on
   its <a>document element</a> using <var>prefix</var>.
  </ol>

 <dt>{{DocumentType}}
 <dt>{{DocumentFragment}}
 <dd>Return null.

 <dt>Any other node
 <dd>
  <ol>
   <li>If its <a>parent element</a> is null, return null.

   <li>Return the result of running <a>locate a namespace</a> on
   its <a>parent element</a> using <var>prefix</var>.
  </ol>
</dl>

The
<dfn method for="Node">lookupPrefix(<var>namespace</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>namespace</var> is null or the empty string, return null.

 <li>
  Otherwise it depends on the <a>context object</a>:

  <dl class=switch>
   <dt>{{Element}}
   <dd>Return the result of
   <a>locating a namespace prefix</a>
   for the node using <var>namespace</var>.

   <!--AttrExodus {{Attr}} -->
   <dt>{{Document}}
   <dd>Return the result of
   <a>locating a namespace prefix</a>
   for its <a>document element</a>, if that is not null, and null
   otherwise.

   <dt>{{DocumentType}}
   <dt>{{DocumentFragment}}
   <dd>Return null.

   <dt>Any other node
   <dd>Return the result of
   <a>locating a namespace prefix</a>
   for its <a>parent element</a>, or if that is null, null.
  </dl>
</ol>

The
<dfn method for="Node">lookupNamespaceURI(<var>prefix</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>prefix</var> is the empty string, set it to null.

 <li>Return the result of running <a>locate a namespace</a> for the
 <a>context object</a> using <var>prefix</var>.
</ol>

The
<dfn method for="Node">isDefaultNamespace(<var>namespace</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>namespace</var> is the empty string, set it to null.

 <li>Let <var>defaultNamespace</var> be the result of running
 <a>locate a namespace</a> for the <a>context object</a> using
 null.

 <li>Return true if <var>defaultNamespace</var> is the same as
 <var>namespace</var>, and false otherwise.
</ol>

<hr>

The
<dfn method for="Node">insertBefore(<var>node</var>, <var>child</var>)</dfn>
method must return the result of
<a>pre-inserting</a>
<var>node</var> into the <a>context object</a> before
<var>child</var>.

The
<dfn method for="Node">appendChild(<var>node</var>)</dfn>
method must return the result of
<a>appending</a> <var>node</var> to
the <a>context object</a>.

The
<dfn method for="Node">replaceChild(<var>node</var>, <var>child</var>)</dfn>
method must return the result of
<a>replacing</a> <var>child</var>
with <var>node</var> within the <a>context object</a>.

The
<dfn method for="Node">removeChild(<var>child</var>)</dfn>
method must return the result of
<a>pre-removing</a>
<var>child</var> from the <a>context object</a>.

<hr><!-- Collections -->

The
<dfn id=concept-getElementsByTagName>list of elements with local name <var>localName</var></dfn>
for a <a>node</a> <var>root</var> is the
{{HTMLCollection}} returned by the following algorithm:
<ol>
 <li>If <var>localName</var> is "<code>*</code>" (U+002A),
 return a {{HTMLCollection}} rooted at <var>root</var>,
 whose filter matches only <a>elements</a>.

 <li>
  Otherwise, if <var>root</var>'s
  <a>node document</a> is an
  <a>HTML document</a>, return a {{HTMLCollection}} rooted at
  <var>root</var>, whose filter matches the following
  <a>descendant</a>
  <a>elements</a>:

  <ul>
   <li>Whose <a for=Element>namespace</a> is the
   <a>HTML namespace</a> and whose
   <a for=Element>local name</a> is
   <var>localName</var> <a>converted to ASCII lowercase</a>.

   <li>Whose <a for=Element>namespace</a> is
   <em>not</em> the <a>HTML namespace</a> and whose
   <a for=Element>local name</a> is
   <var>localName</var>.
  </ul>

 <li>Otherwise, return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches
 <a>descendant</a>
 <a>elements</a> whose
 <a for=Element>local name</a> is
 <var>localName</var>.
</ol>

When invoked with the same argument, the same {{HTMLCollection}}
object may be returned as returned by an earlier call.


The
<dfn id=concept-getElementsByTagNameNS>list of elements with namespace
<var>namespace</var> and local name <var>localName</var></dfn>
for a <a>node</a> <var>root</var> is the
{{HTMLCollection}} returned by the following algorithm:

<ol>
 <li>If <var>namespace</var> is the empty string, set it to null.

 <li>If both <var>namespace</var> and <var>localName</var>
 are "<code>*</code>" (U+002A), return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches
 <a>descendant</a>
 <a>elements</a>.

 <li>Otherwise, if <var>namespace</var> is "<code>*</code>"
 (U+002A), return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches
 <a>descendant</a>
 <a>elements</a> whose
 <a for=Element>local name</a> is
 <var>localName</var>.

 <li>Otherwise, if <var>localName</var> is "<code>*</code>"
 (U+002A), return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches
 <a>descendant</a>
 <a>elements</a> whose
 <a for=Element>namespace</a> is
 <var>namespace</var>.

 <li>Otherwise, return a {{HTMLCollection}} rooted at
 <var>root</var>, whose filter matches
 <a>descendant</a>
 <a>elements</a> whose
 <a for=Element>namespace</a> is
 <var>namespace</var> and
 <a for=Element>local name</a> is
 <var>localName</var>.
</ol>

When invoked with the same arguments, the same {{HTMLCollection}}
object may be returned as returned by an earlier call.


The
<dfn id=concept-getElementsByClassName>list of elements with class names <var>classNames</var></dfn>
for a <a>node</a> <var>root</var> is the
{{HTMLCollection}} returned by the following algorithm:
<ol>
 <li>
  Let <var>classes</var> be the result of running the
  <a>ordered set parser</a> on
  <var>classNames</var>.

 <li>
  If <var>classes</var> is the empty set, return an empty
  {{HTMLCollection}}.

 <li>
  Return a {{HTMLCollection}} rooted at <var>root</var>,
  whose filter matches <a>descendant</a>
  <a>elements</a> that have all their
  <a>classes</a> in <var>classes</var>.

  The comparisons for the <a>classes</a> must be done
  in an <a>ASCII case-insensitive</a> manner if <var>root</var>'s
  <a>node document</a> is in
  <a>quirks mode</a>, and in a
  <a>case-sensitive</a> manner otherwise.
</ol>

When invoked with the same argument, the same {{HTMLCollection}}
object may be returned as returned by an earlier call.


<h3 id='interface-document'>
Interface {{Document}}</h3>

<pre class=idl force="Document<interface>">
[Constructor,
 Exposed=Window]
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  readonly attribute DOMString URL;
  readonly attribute DOMString documentURI;
  readonly attribute DOMString origin;
  readonly attribute DOMString compatMode;
  readonly attribute DOMString characterSet;
  readonly attribute DOMString inputEncoding; // legacy alias of .characterSet
  readonly attribute DOMString contentType;

  readonly attribute DocumentType? doctype;
  readonly attribute Element? documentElement;
  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);

  [NewObject] Element createElement(DOMString localName);
  [NewObject] Element createElementNS(DOMString? namespace, DOMString qualifiedName);
  [NewObject] DocumentFragment createDocumentFragment();
  [NewObject] Text createTextNode(DOMString data);
  [NewObject] Comment createComment(DOMString data);
  [NewObject] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);

  [NewObject] Node importNode(Node node, optional boolean deep = false);
  Node adoptNode(Node node);

  [NewObject] Attr createAttribute(DOMString localName);
  [NewObject] Attr createAttributeNS(DOMString? namespace, DOMString name);

  [NewObject] Event createEvent(DOMString interface);

  [NewObject] Range createRange();

  // NodeFilter.SHOW_ALL = 0xFFFFFFFF
  [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
  [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);
};

[Exposed=Window]
interface XMLDocument : Document {};
</pre>

{{Document}} <a>nodes</a> are simply
known as <dfn id=concept-document>documents</dfn>.

Each <a>document</a> has an associated
<dfn id=concept-document-encoding" lt="document encoding">encoding</dfn>,
<dfn id=concept-document-content-type lt="document content type">content type</dfn>, and
<dfn id=concept-document-url lt="document URL">URL</dfn>.
[[!ENCODING]]
[[!URL]]

Unless stated otherwise, a <a>document</a>'s
<a lt="document encoding">encoding</a> is the
<a>utf-8</a> <a>encoding</a>, its
<a lt="document content type">content type</a> is
"<code>application/xml</code>", and its
<a lt="document URL">URL</a> is
"<code>about:blank</code>".

Unless stated otherwise, a <a>document</a>'s <a>origin</a> is a globally unique identifier
and its <a>effective script origin</a> is an <a lt="origin alias">alias</a> of that <a>origin</a>.
[[!HTML]]

A <a>document</a> is assumed to be an <dfn>XML document</dfn>
unless it is flagged as being an <dfn>HTML document</dfn>.
Whether a <a>document</a> is an <a>HTML document</a> or an <a>XML document</a>
affects the behavior of certain APIs.

A <a>document</a> is always set to one of three modes:
<dfn id=concept-document-no-quirks>no-quirks mode</dfn>, the default;
<dfn id=concept-document-quirks>quirks mode</dfn>, used typically for legacy documents;
and <dfn id=concept-document-limited-quirks>limited-quirks mode</dfn>.
Unless stated otherwise, a <a>document</a> must be in <a>no-quirks mode</a>.

Note: The mode is only ever changed from the default if the
<a>document</a> is created by the
<a>HTML parser</a>, based on the presence,
absence, or value of the DOCTYPE string.
[[!HTML]]

Note: <a>No-quirks mode</a>
was originally known as "standards mode" and
<a>limited-quirks mode</a> was
once known as "almost standards mode". They have been renamed because their
details are now defined by standards. (And because Ian Hickson vetoed their
original names on the basis that they are nonsensical.)

<hr>

<dl class=domintro>
 <dt><code><var>document</var> = new {{Document()}}</code>
 <dd>Returns a new <a>document</a>.

 <dt><code><var>document</var> . {{Document/implementation}}</code>
 <dd>Returns <var>document</var>'s {{DOMImplementation}} object.

 <dt><code><var>document</var> . {{Document/URL}}</code>
 <dt><code><var>document</var> . {{Document/documentURI}}</code>
 <dd>Returns <var>document</var>'s <a lt="document URL">URL</a>.

 <dt><code><var>document</var> . {{Document/origin}}</code>
 <dd>Returns <var>document</var>'s <a>origin</a>.

 <dt><code><var>document</var> . {{Document/compatMode}}</code>
 <dd>
  Returns the string "<code>CSS1Compat</code>" if
  <var>document</var> is in
  <a>no-quirks mode</a> or
  <a>limited-quirks mode</a>, and
  "<code>BackCompat</code>", if <var>document</var> is in
  <a>quirks mode</a>.

 <dt><code><var>document</var> . {{Document/characterSet}}</code>
 <dd>Returns <var>document</var>'s
 <a lt="document encoding">encoding</a>.

 <dt><code><var>document</var> . {{Document/contentType}}</code>
 <dd>Returns <var>document</var>'s
 <a lt="document content type">content type</a>.
</dl>

The <dfn constructor for=Document><code>Document()</code></dfn> constructor
must return a new <a>document</a> whose
<a>origin</a> is an
<a lt="origin alias">alias</a> to the
<a>origin</a> of the global object's associated
<a>document</a>, and
<a>effective script origin</a> is an
<a lt="origin alias">alias</a> to the
<a>effective script origin</a> of the
global object's associated <a>document</a>.
[[!HTML]]

Note: Unlike
{{createDocument()}}
this constructor does not return an {{XMLDocument}} object, but a
<a>document</a> ({{Document}} object).

The
<dfn attribute for="Document">implementation</dfn>
attribute must return the {{DOMImplementation}} object that is
associated with the <a>document</a>.

The <dfn attribute for="Document">URL</dfn> and
<dfn attribute for="Document">documentURI</dfn>
attributes must return the <a lt="document URL">URL</a>.

The <dfn attribute for="Document">origin</dfn>
attribute must return the
<a lt="Unicode serialization of an origin">Unicode serialization</a>
of <a>context object</a>'s <a>origin</a>.

The <dfn attribute for="Document">compatMode</dfn>
attribute must return "<code>BackCompat</code>" if the
<a>context object</a> is in
<a>quirks mode</a>, and
"<code>CSS1Compat</code>" otherwise.

The <dfn attribute for="Document">characterSet</dfn> attribute's
getter and <dfn attribute for="Document">inputEncoding</dfn>
attribute's getter must run these steps:

<ol>
 <li>Let <var>name</var> be
 <a lt="document encoding">encoding</a>'s
 <a lt="encoding name">name</a>.

 <li>
  If <var>name</var> is in the first column in the table below, set
  <var>name</var> to the value of the second column on the same row:

  <!-- The order matches the Encoding Standard -->
  <table>
   <tr>
    <th>Name
    <th>Compatibility name
   <tr>
    <td><a>utf-8</a>
    <td>"<code>UTF-8</code>"
   <tr>
    <td><a>ibm866</a>
    <td>"<code>IBM866</code>"
   <tr>
    <td><a>iso-8859-2</a>
    <td>"<code>ISO-8859-2</code>"
   <tr>
    <td><a>iso-8859-3</a>
    <td>"<code>ISO-8859-3</code>"
   <tr>
    <td><a>iso-8859-4</a>
    <td>"<code>ISO-8859-4</code>"
   <tr>
    <td><a>iso-8859-5</a>
    <td>"<code>ISO-8859-5</code>"
   <tr>
    <td><a>iso-8859-6</a>
    <td>"<code>ISO-8859-6</code>"
   <tr>
    <td><a>iso-8859-7</a>
    <td>"<code>ISO-8859-7</code>"
   <tr>
    <td><a>iso-8859-8</a>
    <td>"<code>ISO-8859-8</code>"
   <tr>
    <td><a>iso-8859-8-i</a>
    <td>"<code>ISO-8859-8-I</code>"
   <tr>
    <td><a>iso-8859-10</a>
    <td>"<code>ISO-8859-10</code>"
   <tr>
    <td><a>iso-8859-13</a>
    <td>"<code>ISO-8859-13</code>"
   <tr>
    <td><a>iso-8859-14</a>
    <td>"<code>ISO-8859-14</code>"
   <tr>
    <td><a>iso-8859-15</a>
    <td>"<code>ISO-8859-15</code>"
   <tr>
    <td><a>iso-8859-16</a>
    <td>"<code>ISO-8859-16</code>"
   <tr>
    <td><a>koi8-r</a>
    <td>"<code>KOI8-R</code>"
   <tr>
    <td><a>koi8-u</a>
    <td>"<code>KOI8-U</code>"
   <!-- macintosh, windows-*, x-mac-cyrillic -->
   <tr>
    <td><a>gbk</a>
    <td>"<code>GBK</code>"
   <!-- gb18030 -->
   <tr>
    <td><a>big5</a>
    <td>"<code>Big5</code>"
   <tr>
    <td><a>euc-jp</a>
    <td>"<code>EUC-JP</code>"
   <tr>
    <td><a>iso-2022-jp</a>
    <td>"<code>ISO-2022-JP</code>"
   <tr>
    <td><a>shift_jis</a>
    <td>"<code>Shift_JIS</code>"
   <tr>
    <td><a>euc-kr</a>
    <td>"<code>EUC-KR</code>"
   <!-- replacement -->
   <tr>
    <td><a>utf-16be</a>
    <td>"<code>UTF-16BE</code>"
   <tr>
    <td><a>utf-16le</a>
    <td>"<code>UTF-16LE</code>"
   <!-- x-user-defined -->
  </table>

 <li>Return <var>name</var>.
</ol>

The <dfn attribute for="Document">contentType</dfn>
attribute must return the
<a lt="document content type">content type</a>.

<hr>

<dl class=domintro>
 <dt><var>document</var> . {{Document/doctype}}
 <dd>Returns the <a>doctype</a> or null if
 there is none.

 <dt><var>document</var> . {{Document/documentElement}}
 <dd>Returns the <a>document element</a>.

 <dt><var>collection</var> = <var>document</var> . {{getElementsByTagName(<var>localName</var>)}}</code>

 <dd>
  If <var>localName</var> is "<code>*</code>" returns a
  {{HTMLCollection}} of all
  <a>descendant</a>
  <a>elements</a>.

  Otherwise, returns a {{HTMLCollection}} of all
  <a>descendant</a>
  <a>elements</a> whose
  <a for=Element>local name</a> is
  <var>localName</var>. (Matches case-insensitively against
  <a>elements</a> in the
  <a>HTML namespace</a> within an <a>HTML document</a>.)

 <dt><var>collection</var> = <var>document</var> . {{getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)}}</code>

 <dd>
  If <var>namespace</var> and <var>localName</var> are
  "<code>*</code>" returns a {{HTMLCollection}} of all
  <a>descendant</a>
  <a>elements</a>.

  If only <var>namespace</var> is "<code>*</code>" returns a
  {{HTMLCollection}} of all
  <a>descendant</a>
  <a>elements</a> whose
  <a for=Element>local name</a> is
  <var>localName</var>.

  If only <var>localName</var> is "<code>*</code>" returns a
  {{HTMLCollection}} of all
  <a>descendant</a>
  <a>elements</a> whose
  <a for=Element>namespace</a> is
  <var>namespace</var>.

  Otherwise, returns a {{HTMLCollection}} of all
  <a>descendant</a>
  <a>elements</a> whose
  <a for=Element>namespace</a> is
  <var>namespace</var> and
  <a for=Element>local name</a> is
  <var>localName</var>.

 <dt><var>collection</var> = <var>document</var> . {{Document/getElementsByClassName(<var>classes</var>)}}</code>
 <dt><var>collection</var> = <var>element</var> . {{Element/getElementsByClassName(<var>classes</var>)}}</code>
 <dd>
  Returns a {{HTMLCollection}} of the
  <a>elements</a> in the object on which
  the method was invoked (a <a>document</a> or
  an <a>element</a>) that have all the classes
  given by <var>classes</var>.
  The <var>classes</var> argument is interpreted as a
  space-separated list of classes.
</dl>

The <dfn attribute for="Document">doctype</dfn> attribute
must return the <a>child</a> of the
<a>document</a> that is a
<a>doctype</a>, and null otherwise.

The
<dfn attribute for="Document">documentElement</dfn>
attribute must return the <a>document element</a>.

The
<dfn method for="Document">getElementsByTagName(<var>localName</var>)</dfn>
method must return the
<a>list of elements with local name <var>localName</var></a>
for the <a>context object</a>.

Note: Thus, in an <a>HTML document</a>,
<code class='lang-javascript'>document.getElementsByTagName("FOO")</code> will match
<code>&lt;FOO></code> elements that are not in the
<a>HTML namespace</a>, and <code>&lt;foo></code> elements that are in
the <a>HTML namespace</a>, but not <code>&lt;FOO></code> elements
that are in the <a>HTML namespace</a>.


The
<dfn method for="Document">getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</dfn>
method must return the
<a>list of elements with namespace <var>namespace</var> and local name <var>localName</var></a>
for the <a>context object</a>.


The
<dfn method for="Document">getElementsByClassName(<var>classNames</var>)</dfn>
method must return the
<a>list of elements with class names <var>classNames</var></a>
for the <a>context object</a>.

<div class="example">
 Given the following XHTML fragment:

 <pre>
  &lt;div id="example"&gt;
    &lt;p id="p1" class="aaa bbb"/&gt;
    &lt;p id="p2" class="aaa ccc"/&gt;
    &lt;p id="p3" class="bbb ccc"/&gt;
  &lt;/div&gt;
 </pre>

 A call to
 <code class="lang-javascript">document.getElementById("example").getElementsByClassName("aaa")</code>
 would return a {{HTMLCollection}} with the two paragraphs
 <code>p1</code> and <code>p2</code> in it.

 A call to
 <code class="lang-javascript">getElementsByClassName("ccc&nbsp;bbb")</code>
 would only return one node, however, namely <code>p3</code>. A call to
 <code class="lang-javascript">document.getElementById("example").getElementsByClassName("bbb&nbsp;&nbsp;ccc&nbsp;")</code>
 would return the same thing.

 A call to
 <code class="lang-javascript">getElementsByClassName("aaa,bbb")</code>
 would return no nodes; none of the elements above are in the
 <code>aaa,bbb</code> class.
</div>

<hr>

<dl class=domintro>
 <dt><var>element</var> = <var>document</var> . {{createElement(<var>localName</var>)}}</code>
 <dd>
  Returns an <a>element</a> in the
  <a>HTML namespace</a> with <var>localName</var> as
  <a for=Element>local name</a>. (In an
  <a>HTML document</a> <var>localName</var> is lowercased.)

  If <var>localName</var> does not match the
  <code><a type>Name</a></code> production an
  {{InvalidCharacterError}}
  exception will be thrown.

 <dt><var>element</var> = <var>document</var> . {{createElementNS(<var>namespace</var>, <var>qualifiedName</var>)}}</code>

 <dd>
  Returns an <a>element</a> with
  <a for=Element>namespace</a>
  <var>namespace</var>. Its
  <a for=Element>namespace prefix</a> will
  be everything before "<code>:</code>" (U+003E) in
  <var>qualifiedName</var> or null. Its
  <a for=Element>local name</a> will be
  everything after "<code>:</code>" (U+003E) in
  <var>qualifiedName</var> or <var>qualifiedName</var>.

  If <var>localName</var> does not match the
  <code><a type>Name</a></code> production an
  {{InvalidCharacterError}}
  exception will be thrown.

  If one of the following conditions is true a
  {{NamespaceError}} exception
  will be thrown:

  <ul>
   <li><var>localName</var> does not match the
   <code><a type>QName</a></code> production.
   <li><a for=Element>Namespace prefix</a>
   is not null and <var>namespace</var> is the empty string.
   <li><a for=Element>Namespace prefix</a>
   is "<code>xml</code>" and <var>namespace</var> is not the
   <a>XML namespace</a>.
   <li><var>qualifiedName</var> or
   <a for=Element>namespace prefix</a>
   is "<code>xmlns</code>" and <var>namespace</var> is not the
   <a>XMLNS namespace</a>.
   <li><var>namespace</var> is the <a>XMLNS namespace</a> and
   neither <var>qualifiedName</var> nor
   <a for=Element>namespace prefix</a>
   is "<code>xmlns</code>".
  </ul>

 <dt><var>documentFragment</var> = <var>document</var> . {{createDocumentFragment()}}</code>
 <dd>Returns a {{DocumentFragment}}
 <a>node</a>.

 <dt><var>text</var> = <var>document</var> . {{createTextNode(<var>data</var>)}}</code>
 <dd>Returns a {{Text}} <a>node</a>
 whose <a>data</a> is <var>data</var>.

 <dt><var>comment</var> = <var>document</var> . {{createComment(<var>data</var>)}}</code>
 <dd>Returns a {{Comment}} <a>node</a>
 whose <a>data</a> is <var>data</var>.

 <dt><var>processingInstruction</var> = <var>document</var> . {{createProcessingInstruction(<var>target</var>, <var>data</var>)}}</code>
 <dd>
  Returns a {{ProcessingInstruction}}
  <a>node</a> whose
  <a lt="PI target">target</a> is <var>target</var> and
  <a>data</a> is <var>data</var>.
  If <var>target</var> does not match the
  <code><a type>Name</a></code> production an
  {{InvalidCharacterError}}
  exception will be thrown.
  If <var>data</var> contains "<code>?></code>" an
  {{InvalidCharacterError}}
  exception will be thrown.
</dl>

The <dfn id=concept-element-interface>element interface</dfn> for any
<var>name</var> and <var>namespace</var> is {{Element}}, unless
stated otherwise.

Note: The HTML Standard will e.g. define that for <code>html</code> and the
<a>HTML namespace</a>, the {{HTMLHtmlElement}} interface is used.
[[!HTML]]

The <dfn method for="Document">createElement(<var>localName</var>)</dfn> method must run the these steps:

<ol>
 <li>If <var>localName</var> does not match the
 <code><a type>Name</a></code> production,
 <a>throw</a> an
 {{InvalidCharacterError}} exception.

 <li>If the <a>context object</a> is an <a>HTML document</a>,
 let <var>localName</var> be
 <a>converted to ASCII lowercase</a>.
 <!-- XXX why restrict this to HTML documents? -->

 <li>Let <var>interface</var> be the
 <a>element interface</a> for
 <var>localName</var> and the <a>HTML namespace</a>.

 <li>Return a new <a>element</a> that implements <var>interface</var>,
 with no attributes,
 <a for=Element>namespace</a> set to the <a>HTML namespace</a>,
 <a for=Element>local name</a> set to <var>localName</var>, and
 <a>node document</a> set to the <a>context object</a>.
</ol>

The
<dfn method for="Document">createElementNS(<var>namespace</var>, <var>qualifiedName</var>)</dfn>
method must run these steps:
<ol>
 <li>Let <var>namespace</var>, <var>prefix</var>, <var>localName</var>, and
 <var>qualifiedName</var> be the result of passing <var>namespace</var> and
 <var>qualifiedName</var> to <a>validate and extract</a>. Rethrow any exceptions.

 <li>Let <var>interface</var> be the
 <a>element interface</a> for
 <var>localName</var> and <var>namespace</var>.

 <li>Return a new <a>element</a> that implements <var>interface</var>,
 with no attributes,
 <a for=Element>namespace</a> set to <var>namespace</var>,
 <a for=Element>namespace prefix</a> set to <var>prefix</var>,
 <a for=Element>local name</a> set to <var>localName</var>, and
 <a>node document</a> set to the <a>context object</a>.
</ol>

The
<dfn method for="Document">createDocumentFragment()</dfn>
method must return a new {{DocumentFragment}}
<a>node</a> with its
<a>node document</a> set to the
<a>context object</a>.

The
<dfn method for="Document">createTextNode(<var>data</var>)</dfn>
method must return a new {{Text}}
<a>node</a> with its
<a>data</a> set to <var>data</var> and
<a>node document</a> set to the
<a>context object</a>.
Note: No check is performed that <var>data</var> consists of
characters that match the <a type>Char</a> production.

The
<dfn method for="Document">createComment(<var>data</var>)</dfn>
method must return a new {{Comment}}
<a>node</a> with its
<a>data</a> set to <var>data</var> and
<a>node document</a> set to the
<a>context object</a>.
Note: No check is performed that <var>data</var> consists of
characters that match the <a type>Char</a> production
or that it contains two adjacent hyphens or ends with a hyphen.

The <dfn method for=Document>createProcessingInstruction(<var>target</var>, <var title>data</var>)</dfn> method must run these steps:

<ol>
 <li>If <var>target</var> does not match the
 <!--<code data-anolis-type>PITarget</code>-->
 <code><a type>Name</a></code> production,
 <a>throw</a> an
 {{InvalidCharacterError}} exception. <!-- DOM3 does not check for "xml" -->

 <li>If <var>data</var> contains the string
 "<code>?></code>", <a>throw</a> an
 {{InvalidCharacterError}} exception. <!-- Gecko does this. -->

 <!--<li>If <var>target</var> contains a U+003A COLON (":")
 character, <a>throw</a> a
 {{NamespaceError}} exception.-->
 <!-- DOM3 didn't check this -->

 <li>Return a new {{ProcessingInstruction}}
 <a>node</a>, with
 <a lt="PI target">target</a> set to <var>target</var>,
 <a>data</a> set to <var>data</var>, and
 <a>node document</a> set to the
 <a>context object</a>.
</ol>

Note: No check is performed that <var>target</var> contains
"<code>xml</code>" or "<code>:</code>", or that
<var>data</var> contains characters that match the
<a type>Char</a> production.

<hr>

<dl class=domintro>
 <dt><var>clone</var> = <var>document</var> . <a method lt=importNode()>importNode(<var>node</var> [, <var>deep</var> = false])</a>
 <dd>
 <dd>
  Returns a copy of <var>node</var>. If
  <var>deep</var> is true, the copy also includes the
  <var>node</var>'s <a>descendants</a>.

  If <var>node</var> is a
  <a>document</a> throws a
  {{NotSupportedError}}
  exception.

 <dt><var>node</var> = <var>document</var> . {{adoptNode(<var>node</var>)}}

 <dd>
  Moves <var>node</var> from another
  <a>document</a> and returns it.

  If <var>node</var> is a
  <a>document</a> throws a
  {{NotSupportedError}}
  exception.
</dl>

The
<dfn method for="Document" lt="importNode(node, deep)|importNode(node)">importNode(<var>node</var>, <var>deep</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>node</var> is a
 <a>document</a>,
 <a>throw</a> a
 {{NotSupportedError}} exception.

 <li>Return a <a lt="clone a node">clone</a> of
 <var>node</var>, with <a>context object</a> and the
 <i>clone children flag</i> set if <var>deep</var> is true.
</ol>

<a lt="Other applicable specifications">Specifications</a> may define
<dfn id=concept-node-adopt-ext>adopting steps</dfn> for all or some
<a>nodes</a>. The algorithm is passed <var>node</var> and
<var>oldDocument</var>, as indicated in the
<a>adopt</a> algorithm.

To <dfn id=concept-node-adopt>adopt</dfn> a <var>node</var> into
a <var>document</var>, run these steps:

<ol>
 <li>Let <var>oldDocument</var> be <var>node</var>'s
 <a>node document</a>.

 <li>If <var>node</var>'s
 <a>parent</a> is not null,
 <a>remove</a> <var>node</var> from
 its <a>parent</a>.

 <li>Set <var>node</var>'s
 <a>inclusive descendants</a>'s
 <a>node document</a> to <var>document</var>.
 <!--AttrExodus as well as any associated {{Attr}} nodes-->

 <li>Run any <a>adopting steps</a> defined for
 <var>node</var> in <a>other applicable specifications</a> and pass
 <var>node</var> and <var>oldDocument</var> as parameters.
</ol>

The
<dfn method for="Document">adoptNode(<var>node</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>node</var> is a
 <a>document</a>,
 <a>throw</a> a
 {{NotSupportedError}} exception.

 <li><a>Adopt</a> <var>node</var>
 into the <a>context object</a>.

 <li>Return <var>node</var>.
</ol>

<hr>

The
<dfn method for="Document">createAttribute(<var>localName</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>If <var>localName</var> does not match the <code><a type>Name</a></code>
 production in XML, <a>throw</a> an
 {{InvalidCharacterError}} exception.

 <li>Return a new <a>attribute</a> whose
 <a for=Attr>local name</a> is <var>localName</var>.
</ol>

Note: This method does not have its input
<a>converted to ASCII lowercase</a>.

The
<dfn method for="Document">createAttributeNS(<var>namespace</var>, <var>name</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>Let <var>namespace</var>, <var>prefix</var>, <var>localName</var>, and
 <var>name</var> be the result of passing <var>namespace</var> and <var>name</var> to
 <a>validate and extract</a>. Rethrow any exceptions.

 <li>Return a new <a>attribute</a> whose
 <a for=Attr>namespace</a> is <var>namespace</var>,
 <a for=Attr>namespace prefix</a> is
 <var>prefix</var>, <a for=Attr>local name</a> is
 <var>localName</var>, and <a for=Attr>name</a> is
 <var>name</var>.
</ol>

<hr>

The
<dfn method for="Document">createEvent(<var>interface</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>constructor</var> be null.

 <li>
  If <var>interface</var> is an
  <a>ASCII case-insensitive</a> match for any of the strings in the
  first column in the following table, set <var>constructor</var> to the
  interface in the second column on the same row as the matching string:

  <table>
   <thead>
    <tr><th>String<th>Interface<td>Notes
   <tbody>
    <tr><td>"<code>customevent</code>"<td>{{CustomEvent}}<td rowspan=4>
    <tr><td>"<code>event</code><td rowspan=3>{{Event}}
    <tr><td>"<code>events</code>"
    <tr><td>"<code>htmlevents</code>"
    <tr><td>"<code>keyboardevent</code>"<td rowspan=2>{{KeyboardEvent}}<td rowspan=2>[[!UIEVENTS]]
    <tr><td>"<code>keyevents</code>"
    <tr><td>"<code>messageevent</code>"<td>{{MessageEvent}}<td>[[!HTML]]
    <tr><td>"<code>mouseevent</code>"<td rowspan=2>{{MouseEvent}}<td rowspan=2>[[!UIEVENTS]]
    <tr><td>"<code>mouseevents</code>"
    <tr><td>"<code>touchevent</code>"<td>{{TouchEvent}}<td class=XXX>
    <tr><td>"<code>uievent</code>"<td rowspan=2>{{UIEvent}}<td rowspan=2>[[!UIEVENTS]]
    <tr><td>"<code>uievents</code>"
  </table>
  <!-- XXX WebKit's architecture is broken here and both browsers support more than DOM.
       https://trac.webkit.org/browser/trunk/Source/WebCore/dom/EventNames.in
       https://mxr.mozilla.org/mozilla-central/source/content/events/src/nsEventDispatcher.cpp#819 -->

 <li>If <var>constructor</var> is null, <a>throw</a> a
 {{NotSupportedError}}.

 <li>Let <var>event</var> be the result of
 <a>invoking</a> the initial value of
 <var>constructor</var> with the empty string as argument.
 <!-- "initial value" as in before script could get to it -->

 <li>Unset <var>event</var>'s <a>initialized flag</a>.

 <li>Return <var>event</var>.
</ol>

<p class="note"><a>Event</a> constructors can be used instead.

<hr>

The <dfn method for="Document">createRange()</dfn>
method must return a new <a>range</a> with
(<a>context object</a>, 0) as its
<a>start</a> and
<a>end</a>.

Note: The {{Range/Range()}} constructor can be used instead.

<hr>

The
<dfn method for="Document">createNodeIterator(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</dfn>
method must run these steps:

<ol>
 <li>Create a {{NodeIterator}} object.
 <li>Set <a for="traversal">root</a> and initialize
 the {{NodeIterator/referenceNode}}
 attribute to the <var>root</var> argument.
 <li>Initialize the
 {{NodeIterator/pointerBeforeReferenceNode}}
 attribute to true.
 <li>Set <a for="traversal">whatToShow</a> to
 the <var>whatToShow</var> argument.
 <li>Set <a for="traversal">filter</a> to
 <var>filter</var>.
 <li>Return the newly created {{NodeIterator}} object.
</ol>

The
<dfn method for="Document">createTreeWalker(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</dfn>
method must run these steps:

<ol>
 <li>Create a {{TreeWalker}} object.
 <li>Set <a for="traversal">root</a> and initialize
 the {{TreeWalker/currentNode}} attribute to
 the <var>root</var> argument.
 <li>Set <a for="traversal">whatToShow</a> to
 the <var>whatToShow</var> argument.
 <li>Set <a for="traversal">filter</a> to
 <var>filter</var>.
 <li>Return the newly created {{TreeWalker}} object.
</ol>



<h4 id='interface=domimplementation'>
Interface {{DOMImplementation}}</h4>

User agents must create a {{DOMImplementation}} object whenever
a <a>document</a> is created and associate it
with that <a>document</a>.

<pre class=idl>
[Exposed=Window]
interface DOMImplementation {
  [NewObject] DocumentType createDocumentType(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] XMLDocument createDocument(DOMString? namespace, [TreatNullAs=EmptyString] DOMString qualifiedName, optional DocumentType? doctype = null);
  [NewObject] Document createHTMLDocument(optional DOMString title);

  boolean hasFeature(); // useless; always returns true
};
</pre>

<dl class=domintro>
 <dt><code><var>doctype</var> = <var>document</var> . {{Document/implementation}} . {{createDocumentType(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)}}</code>

 <dd>
  Returns a <a>doctype</a>, with the given
  <var>qualifiedName</var>, <var>publicId</var>, and
  <var>systemId</var>. If <var>qualifiedName</var> does not
  match the <code><a type>Name</a></code> production, an
  {{InvalidCharacterError}}
  exception is thrown, and if it does not match the
  <code><a type>QName</a></code> production, a
  {{NamespaceError}} exception
  is thrown.

 <dt><code><var>doc</var> = <var>document</var> . {{Document/implementation}} . <a method lt="createDocument()">createDocument(<var>namespace</var>, <var>qualifiedName</var> [, <var>doctype</var> = null])</a></code>

 <dd>
  Returns an {{XMLDocument}}, with a
  <a>document element</a> whose
  <a for=Element>local name</a> is
  <var>qualifiedName</var> and whose
  <a for=Element>namespace</a> is
  <var>namespace</var> (unless <var>qualifiedName</var> is the
  empty string), and with <var>doctype</var>, if it is given, as its
  <a>doctype</a>.

  This method throws the same exceptions as the {{createElementNS()}} method, when
  invoked with the same arguments.

 <dt><code><var>doc</var> = <var>document</var> . {{Document/implementation}} . <a lt="createHTMLDocument()">createHTMLDocument([<var>title</var>])</a></code>

 <dd>
  Returns a <a>document</a>, with a basic
  <a>tree</a> already constructed including a
  <{title}> element, unless the <var>title</var>
  argument is omitted.
</dl>

<div class=impl>

The
<dfn method for="DOMImplementation">createDocumentType(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</dfn>
method must run these steps:

<ol>
 <li><a>Validate</a> <var>qualifiedName</var>. Rethrow any exceptions.
 <!-- <li>If <var>publicId</var> contains a character that does not
 match the <code><a>PubidChar</a></code> production in XML,
 <a>throw</a> an
 {{InvalidCharacterError}}
 exception. --> <!-- DOM3 didn't check this -->
 <!--<li>If <var>systemId</var> contains both a U+0022 QUOTATION MARK ('"') and a U+0027 APOSTROPHE ("'") character,
 <a>throw</a> an
 {{InvalidCharacterError}}
 exception.--> <!-- DOM3 didn't check this -->
 <li>Return a new <a>doctype</a>, with
 <var>qualifiedName</var> as its
 <a lt="doctype name">name</a>, <var>publicId</var> as
 its <a>public ID</a>, and
 <var>systemId</var> as its
 <a>system ID</a>, and with its
 <a>node document</a> set to the
 associated <a>document</a> of the
 <a>context object</a>.
</ol>
Note: No check is performed that <var>publicId</var>
matches the <code>PublicChar</code> production or that
<var>systemId</var> does not contain both a '<code>"</code>' and
"<code>'</code>".

The
<dfn method for="DOMImplementation">createDocument(<var>namespace</var>, <var>qualifiedName</var>, <var>doctype</var>)</dfn>
method must run these steps:

<ol>
 <li>
  Let <var>document</var> be a new {{XMLDocument}}.

  Note: This method creates an {{XMLDocument}} rather than
  a normal <a>document</a>. They are identical
  except for the addition of the
  {{XMLDocument/load()}}
  method deployed content relies upon.
  [[!HTML]]

 <li>Let <var>element</var> be null.

 <li>If <var>qualifiedName</var> is not the empty string, set
 <var>element</var> to the result of invoking the
 {{Document/createElementNS()}} method
 with the arguments <var>namespace</var> and
 <var>qualifiedName</var> on <var>document</var>. Rethrow any exceptions.
 <!-- XXX needs cleanup -->

 <li>If <var>doctype</var> is not null,
 <a>append</a>
 <var>doctype</var> to <var>document</var>.

 <li>If <var>element</var> is not null,
 <a>append</a>
 <var>element</var> to <var>document</var>.

 <li><var>document</var>'s
 <a>origin</a> is an
 <a lt="origin alias">alias</a> to the
 <a>origin</a> of the
 <a>context object</a>'s associated
 <a>document</a>, and
 <var>document</var>'s
 <a>effective script origin</a> is an
 <a lt="origin alias">alias</a> to the
 <a>effective script origin</a> of the
 <a>context object</a>'s associated
 <a>document</a>.
 [[!HTML]]

 <li>Return <var>document</var>.
</ol>

The
<dfn method for="DOMImplementation">createHTMLDocument(<var>title</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>doc</var> be a new
 <a>document</a> that is an
 <a>HTML document</a>.

 <li>Set <var>doc</var>'s
 <a lt="document content type">content type</a> to
 "<code>text/html</code>".

 <li>Create a <a>doctype</a>, with
 "<code>html</code>"
 as its <a lt="doctype name">name</a> and with its
 <a>node document</a> set to
 <var>doc</var>. <a>Append</a>
 the newly created node to <var>doc</var>.

 <li>Create an <{html}> element in the <span>HTML
 namespace</span>, and <a>append</a>
 it to <var>doc</var>.

 <li>Create a <{head}> element in the <span>HTML
 namespace</span>, and  <a>append</a>
 it to the <{html}> element created in the previous step.

 <li>
  If the <var>title</var> argument is not omitted:

  <ol>
   <li>Create a <{title}> element in the
   <a>HTML namespace</a>, and
   <a>append</a> it to the
   <{head}> element created in the previous step.

   <li>Create a {{Text}} <a>node</a>,
   set its <a>data</a> to <var>title</var>
   (which could be the empty string), and
   <a>append</a> it to the
   <{title}> element created in the previous step.
  </ol>

 <li>Create a <{body}> element in the
 <a>HTML namespace</a>, and
 <a>append</a> it to the
 <{html}> element created in the earlier step.

 <li><var>doc</var>'s
 <a>origin</a> is an
 <a lt="origin alias">alias</a> to the
 <a>origin</a> of the
 <a>context object</a>'s associated
 <a>document</a>, and
 <var>doc</var>'s
 <a>effective script origin</a> is an
 <a lt="origin alias">alias</a> to the
 <a>effective script origin</a> of the
 <a>context object</a>'s associated
 <a>document</a>.
 [[!HTML]]

 <li>Return <var>doc</var>.
</ol>

The <dfn method for="DOMImplementation">hasFeature()</dfn> method
must return true.

Note: {{hasFeature()}}
originally would report whether the user agent claimed to support a given DOM
feature, but experience proved it was not nearly as reliable or granular as
simply checking whether the desired objects, attributes, or methods existed.
As such, it should no longer be used, but continues to exist (and simply
returns true) so that old pages don't stop working.

</div>


<h3 id='interface-documentfragment'>Interface {{DocumentFragment}}</h3>
<pre class=idl>
[Constructor,
 Exposed=Window]
interface DocumentFragment : Node {
};
</pre>

A {{DocumentFragment}} <a>node</a> can have an
associated <a>element</a> named
<dfn id=concept-DocumentFragment-host lt="DocumentFragment host">host</dfn>.

An object <var>A</var> is a
<dfn id=concept-tree-host-including-inclusive-ancestor>host-including inclusive ancestor</dfn>
of an object <var>B</var>, if either <var>A</var> is an
<a>inclusive ancestor</a> of
<var>B</var>, or if <var>B</var>'s <a for=tree>root</a>
has an associated <a lt="DocumentFragment host">host</a> and
<var>A</var> is a
<a>host-including inclusive ancestor</a>
of <var>B</var>'s <a for=tree>root</a>'s
<a lt="DocumentFragment host">host</a>.

Note: The {{DocumentFragment}} <a>node</a>'s
<a lt="DocumentFragment host">host</a> concept is useful for HTML's
<{template}> element and the {{ShadowRoot}} object and impacts the
<a>pre-insert</a> and
<a>replace</a> algorithms.

<!-- XXX xref
     XXX ShadowRoot is a Node technically -->

<dl class=domintro>
 <dt><code><var>tree</var> = new {{DocumentFragment()}}</code>
 <dd>Returns a new {{DocumentFragment}} <a>node</a>.
</dl>

The <dfn constructor for=DocumentFragment>DocumentFragment()</dfn> constructor
must return a new {{DocumentFragment}} <a>node</a> whose
<a>node document</a> is the global object's associated
<a>document</a>.


<h3 id='interface-documenttype'>Interface {{DocumentType}}</h3>

<pre class=idl>
[Exposed=Window]
interface DocumentType : Node {
  readonly attribute DOMString name;
  readonly attribute DOMString publicId;
  readonly attribute DOMString systemId;
};
</pre>

{{DocumentType}} <a>nodes</a> are
simply known as <dfn id=concept-doctype>doctypes</dfn>.

<a>Doctypes</a> have an associated
<dfn id=concept-doctype-name lt="doctype name">name</dfn>,
<dfn id=concept-doctype-publicid>public ID</dfn>, and
<dfn id=concept-doctype-systemid>system ID</dfn>.

When a <a>doctype</a> is created, its
<a lt="doctype name">name</a> is always given. Unless
explicitly given when a <a>doctype</a> is
created, its <a>public ID</a> and
<a>system ID</a> are the empty string.

The <dfn attribute for="DocumentType">name</dfn> attribute
must return the <a lt="doctype name">name</a>.

The <dfn attribute for="DocumentType">publicId</dfn>
attribute must return the
<a>public ID</a>.

The <dfn attribute for="DocumentType">systemId</dfn>
attribute must return the
<a>system ID</a>.



<h3 id='interface-element'>Interface {{Element}}</h3>

<pre class=idl>
[Exposed=Window]
interface Element : Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString tagName;

           attribute DOMString id;
           attribute DOMString className;
  [SameObject] readonly attribute DOMTokenList classList;

  boolean hasAttributes();
  [SameObject] readonly attribute NamedNodeMap attributes;
  DOMString? getAttribute(DOMString name);
  DOMString? getAttributeNS(DOMString? namespace, DOMString localName);
  void setAttribute(DOMString name, DOMString value);
  void setAttributeNS(DOMString? namespace, DOMString name, DOMString value);
  void removeAttribute(DOMString name);
  void removeAttributeNS(DOMString? namespace, DOMString localName);
  boolean hasAttribute(DOMString name);
  boolean hasAttributeNS(DOMString? namespace, DOMString localName);

  Attr? getAttributeNode(DOMString name);
  Attr? getAttributeNodeNS(DOMString? namespace, DOMString localName);
  Attr? setAttributeNode(Attr attr);
  Attr? setAttributeNodeNS(Attr attr);
  Attr removeAttributeNode(Attr attr);

  Element? closest(DOMString selectors);
  boolean matches(DOMString selectors);

  HTMLCollection getElementsByTagName(DOMString localName);
  HTMLCollection getElementsByTagNameNS(DOMString? namespace, DOMString localName);
  HTMLCollection getElementsByClassName(DOMString classNames);
};</pre>


{{Element}} <a>nodes</a> are simply
known as <dfn id=concept-element lt="element">elements</dfn>.

<a>Elements</a> have an associated
<dfn id=concept-element-namespace for=Element>namespace</dfn>,
<dfn id=concept-element-namespace-prefix for=Element>namespace prefix</dfn>, and
<dfn id=concept-element-local-name for=Element>local name</dfn>. When an
<a>element</a> is created, its
<a for=Element>local name</a> is always given.
Unless explicitly given when an <a>element</a>
is created, its <a for=Element>namespace</a> and
<a for=Element>namespace prefix</a> are
null.

<a>Elements</a> also have an ordered
<dfn id=concept-element-attribute for=Element>attribute list</dfn> exposed through a
{{NamedNodeMap}}. Unless explicitly given when an
<a>element</a> is created, its
<a for=Element>attribute list</a> is empty. An
<a>element</a>
<dfn id=concept-element-attribute-has lt="has an attribute">has</dfn> an
<a>attribute</a> <var>A</var> if
<var>A</var> is in its
<a for=Element>attribute list</a>.

<a lt="other applicable specifications">Applicable specifications</a>
and this specification (can) use the hooks an <dfn>attribute is set</dfn>,
an <dfn>attribute is changed</dfn>, an <dfn>attribute is added</dfn>, and
an <dfn>attribute is removed</dfn>, for further processing of the
<a>attribute</a>'s
<a for=Attr>value</a>.

To <dfn id=concept-element-attributes-change lt="change an attribute">change</dfn> an
<a>attribute</a> <var>attribute</var>
from an <a>element</a> <var>element</var>
to <var>value</var>, run these steps:

<ol>
 <li><a>Queue a mutation record</a> of "<code>attributes</code>"
 for <var>element</var> with name <var>attribute</var>'s
 <a for=Attr>local name</a>, namespace
 <var>attribute</var>'s
 <a for=Attr>namespace</a>, and oldValue
 <var>attribute</var>'s
 <a for=Attr>value</a>.

 <li>Set <var>attribute</var>'s
 <a for=Attr>value</a> to <var>value</var>.

 <li>An <a>attribute is set</a> and an
 <a>attribute is changed</a>.
</ol>

To <dfn id=concept-element-attributes-append lt="append an attribute">append</dfn> an
<a>attribute</a> <var>attribute</var> to
an <a>element</a> <var>element</var>,
run these steps:

<ol>
 <li><a>Queue a mutation record</a> of "<code>attributes</code>"
 for <var>element</var> with name <var>attribute</var>'s
 <a for=Attr>local name</a>, namespace
 <var>attribute</var>'s
 <a for=Attr>namespace</a>, and oldValue
 null.

 <li>Append the <var>attribute</var> to the <var>element</var>'s
 <a for=Element>attribute list</a>.

 <li>Set <var>attribute</var>'s
 <a for=Attr lt="attribute element">element</a> to <var>element</var>.

 <li>An <a>attribute is set</a> and an
 <a>attribute is added</a>.
</ol>

To <dfn id=concept-element-attributes-remove lt="remove an attribute">remove</dfn> an
<a>attribute</a> <var>attribute</var>
from an <a>element</a> <var>element</var>,
run these steps:

<ol>
 <li><a>Queue a mutation record</a> of "<code>attributes</code>"
 for <var>element</var> with name <var>attribute</var>'s
 <a for=Attr>local name</a>, namespace
 <var>attribute</var>'s
 <a for=Attr>namespace</a>, and oldValue
 <var>attribute</var>'s
 <a for=Attr>value</a>.

 <li>Remove <var>attribute</var> from the
 <var>element</var>'s
 <a for=Element>attribute list</a>.

 <li>Set <var>attribute</var>'s
 <a for=Attr lt="attribute element">element</a> to null.

 <li>An <a>attribute is removed</a>.
</ol>

<hr>

To <dfn id=concept-element-attributes-get-by-name>get an attribute by name</dfn>
given a <var>name</var> and <a>element</a>
<var>element</var>, run these steps:

<ol>
 <li>If <var>element</var> is in the <a>HTML namespace</a> and its
 <a>node document</a> is an
 <a>HTML document</a>, let <var>name</var> be
 <a>converted to ASCII lowercase</a>.

 <li>Return the first <a>attribute</a> in
 <var>element</var>'s <a for=Element>attribute list</a>
 whose <a for=Attr>name</a> is <var>name</var>, and null
 otherwise.
</ol>

To
<dfn id=concept-element-attributes-get-by-namespace>get an attribute by namespace and local name</dfn>
given a <var>namespace</var>, <var>localName</var>, and
<a>element</a> <var>element</var>, run these steps:

<ol>
 <li>If <var>namespace</var> is the empty string, set it to null.

 <li>Return the <a>attribute</a> in
 <var>element</var>'s <a for=Element>attribute list</a>
 whose <a for="Attr">namespace</a> is
 <var>namespace</var> and
 <a for="Attr">local name</a> is
 <var>localName</var>, if any, and null otherwise.
</ol>

To <dfn id=concept-element-attributes-set>set an attribute</dfn> given an
<a>attribute</a> <var>attr</var>,
<a>element</a> <var>element</var>, and optionally a
<i>namespace and local name flag</i>, run these steps:

<ol>
 <li>If <var>attr</var>'s <a for=Attr lt="attribute element">element</a> is
 neither null nor <var>element</var>, <a>throw</a> an
 {{InUseAttributeError}}.

 <li>Let <var>oldAttr</var> be null.

 <li>If the <i>namespace and local name flag</i> is set, set <var>oldAttr</var>
 to the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a>
 given <var>attr</var>'s <a for="Attr">namespace</a>,
 <var>attr</var>'s <a for="Attr">local name</a>, and
 <var>element</var>.

 <li>
  Otherwise, set <var>oldAttr</var> to the result of
  <a lt="get an attribute by name">getting an attribute</a> given
  <var>attr</var>'s <a for=Attr>name</a> and
  <var>element</var>.

  <p class="note no-backref">The result of this is that an
  <a>attribute</a> on an
  <a>element</a> with an <a>HTML namespace</a> in an
  <a>HTML document</a> can be replaced with another
  <a>attribute</a> whose
  <a for=Attr>name</a> is only an
  <a>ASCII case-insensitive</a> match. We do not care, because nobody ought to be
  working with <a>attributes</a> in this way.

 <li>If <var>oldAttr</var> is <var>attr</var>, return <var>attr</var>.

 <li>If <var>oldAttr</var> is non-null,
 <a lt="remove an attribute">remove</a> it from
 <var>element</var>.

 <li><a lt="append an attribute">Append</a> <var>attr</var>
 to <var>element</var>.

 <li>Return <var>oldAttr</var>.
</ol>

To <dfn id=concept-element-attributes-set-value>set an attribute value</dfn> for
an <a>element</a> <var>element</var>
using a <var>localName</var> and <var>value</var>, and
optionally a <var>name</var>, <var>prefix</var>, and
<var>namespace</var>, run these steps:

<ol>
 <li>If <var>name</var> is not given, set it to <var>localName</var>.

 <li>If <var>prefix</var> is not given, set it to null.

 <li>If <var>namespace</var> is not given, set it to null.

 <li>Let <var>attribute</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li>If <var>attribute</var> is null, create an
 <a>attribute</a> whose
 <a for=Attr>namespace</a> is <var>namespace</var>,
 <a for=Attr>namespace prefix</a> is
 <var>prefix</var>, <a for=Attr>local name</a> is
 <var>localName</var>, <a for=Attr>name</a> is <var>name</var>,
 and <a for=Attr>value</a> is <var>value</var>, and then
 <a lt="append an attribute">append</a> this
 <a>attribute</a> to <var>element</var>
 and terminate these steps.

 <li><a lt="change an attribute">Change</a>
 <var>attribute</var> from <var>element</var> to
 <var>value</var>.
</ol>

To
<dfn id=concept-element-attributes-remove-by-name>remove an attribute by name</dfn>
given a <var>name</var> and <a>element</a>
<var>element</var>, run these steps:

<ol>
 <li>Let <var>attr</var> be the result of
 <a lt="get an attribute by name">getting an attribute</a> given
 <var>name</var> and <var>element</var>.

 <li>If <var>attr</var> is non-null,
 <a lt="remove an attribute">remove</a> it from
 <var>element</var>.

 <li>Return <var>attr</var>.
</ol>

To
<dfn id=concept-element-attributes-remove-by-namespace>remove an attribute by namespace and local name</dfn>
given a <var>namespace</var>, <var>localName</var>, and
<a>element</a> <var>element</var>, run these steps:

<ol>
 <li>Let <var>attr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a> given
 <var>namespace</var>, <var>localName</var>, and <var>element</var>.

 <li>If <var>attr</var> is non-null,
 <a lt="remove an attribute">remove</a> it from
 <var>element</var>.

 <li>Return <var>attr</var>.
</ol>

<hr>

<a>Elements</a> can have an associated
<dfn id=concept-id lt="element ID" local-lt="ID">unique identifier (ID)</dfn> and have an associated
{{DOMTokenList}} object. The {{DOMTokenList}} object's
associated <a>attribute</a>'s
<a for=Attr>local name</a> is
<code>class</code> and its associated ordered set of tokens is called
the <a>element</a>'s
<dfn id=concept-class>classes</dfn>.

Note: Historically <a>elements</a> could
have multiple identifiers e.g. by using the HTML <code>id</code>
<a>attribute</a> and a DTD. This specification
makes <a>ID</a> a concept of the DOM and allows for
only one per <a>element</a>, given by an
<a lt="named attribute"><code>id</code> attribute</a>.

Either when an <a>element</a> is created that
<a lt="has an attribute">has</a> an
<a lt="named attribute"><code>id</code> attribute</a> whose
<a for=Attr>value</a> is not the empty string or
when an <a>element</a>'s
<a lt="named attribute"><code>id</code> attribute</a> is
<a lt="attribute is set">set</a> to a
<a for=Attr>value</a> other than the empty
string, set the <a>element</a>'s
<a>ID</a> to the new
<a for=Attr>value</a>.

When an <a>element</a>'s
<a lt="named attribute"><code>id</code> attribute</a> is
<a lt="attribute is removed">removed</a> or
<a lt="attribute is set">set</a> to the empty string, unset the
<a>element</a>'s
<a>ID</a>.

Either when an <a>element</a> is created that
<a lt="has an attribute">has</a> a
<a lt="named attribute"><code>class</code> attribute</a> or
when an <a>element</a>'s
<a lt="named attribute"><code>class</code> attribute</a> is
<a lt="attribute is set">set</a>, set the
<a>element</a>'s
<a>classes</a> to the new
<a for=Attr>value</a>,
<a lt="ordered set parser">parsed</a>.

When an <a>element</a>'s
<a lt="named attribute"><code>class</code> attribute</a> is
<a lt="attribute is removed">removed</a>, set the
<a>element</a>'s
<a>classes</a> to the empty set.

Note: While this specification defines user agent processing
requirements for <code>id</code> and <code>class</code>
<a>attributes</a> on any
<a>element</a>, it makes no claims as to whether
using them is conforming or not.

<hr>

A <a>node</a>'s
<a>parent</a> of type
{{Element}} is known as a <dfn>parent element</dfn>. If the
<a>node</a> has a
<a>parent</a> of a different type, its
<a>parent element</a> is null.

The <dfn>document element</dfn> of a
<a>document</a> is the
<a>element</a> whose
<a>parent</a> is that
<a>document</a>, if it exists, and null otherwise.

Note: Per the <a>node tree</a>
constraints, there can only be one such
<a>element</a>.

When an <a>element</a> or one of its
<a>ancestors</a> is the
<a>document element</a>, it is <dfn>in a document</dfn>.

<hr>

<dl class=domintro>
 <dt><var>namespace</var> = <var>element</var> . {{Element/namespaceURI}}
 <dd>Returns the <a for=Element>namespace</a>.

 <dt><var>prefix</var> = <var>element</var> . {{Element/prefix}}
 <dd>Returns the
 <a for=Element>namespace prefix</a>.

 <dt><var>localName</var> = <var>element</var> . {{Element/localName}}
 <dd>Returns the
 <a for=Element>local name</a>.

 <dt><var>qualifiedName</var> = <var>element</var> . {{Element/tagName}}
 <dd>If
 <a for=Element>namespace prefix</a> is not
 null, returns the concatenation of
 <a for=Element>namespace prefix</a>,
 "<code>:</code>", and
 <a for=Element>local name</a>. Otherwise it
 returns the <a for=Element>local name</a>.
 (The return value is uppercased in an <a>HTML document</a>.)
</dl>

The <dfn attribute for="Element">namespaceURI</dfn>
attribute must return the <a>context object</a>'s
<a for=Element>namespace</a>.

The <dfn attribute for="Element">prefix</dfn> attribute must return the <a>context object</a>'s
<a for=Element>namespace prefix</a>.

The <dfn attribute for="Element">localName</dfn>
attribute must return the <a>context object</a>'s
<a for=Element>local name</a>.

The <dfn attribute for="Element">tagName</dfn> attribute
must run these steps:
<ol>
 <li>If <a>context object</a>'s
 <a for=Element>namespace prefix</a> is not
 null, let <var>qualified name</var> be its
 <a for=Element>namespace prefix</a>, followed
 by a "<code>:</code>" (U+003A), followed by its
 <a for=Element>local name</a>. Otherwise, let
 <var>qualified name</var> be its
 <a for=Element>local name</a>.

 <li>If the <a>context object</a> is in the <a>HTML namespace</a> and
 its <a>node document</a> is an
 <a>HTML document</a>, let <var>qualified name</var> be
 <span>converted to ASCII uppercase</span>.

 <li>Return <var>qualified name</var>.
</ol>

<hr>

Some IDL attributes are defined to <dfn id=concept-reflect>reflect</dfn> a content
<a>attribute</a> of a given <var>name</var>. This
means that on getting, these steps must be run:

<ol>
 <li>Let <var>attr</var> be the result of
 <a lt="get an attribute by namespace and local name">getting an attribute</a>
 given null, <var>name</var>, and the <a>context object</a>.

 <li>If <var>attr</var> is null, return the empty string.

 <li>Return <var>attr</var>'s <a for=Attr>value</a>.
</ol>

On setting,
<a>set an attribute value</a> for the
<a>context object</a> using <var>name</var> and the given value.

The <dfn attribute for="Element">id</dfn> attribute must
<a>reflect</a> the "<code>id</code>"
content attribute.

The <dfn attribute for="Element">className</dfn>
attribute must <a>reflect</a> the
"<code>class</code>" content attribute.

The <dfn attribute for="Element">classList</dfn>
attribute must return the associated {{DOMTokenList}} object
representing the <a>context object</a>'s
<a>classes</a>.

<hr>

<!-- all members in this subsection are affected by AttrExodus -->

The <dfn method for="Element">hasAttributes()</dfn> method,
when invoked, must return false if <a>context object</a>'s
<a for=Element>attribute list</a> is empty, and true
otherwise.

The <dfn attribute for="Element">attributes</dfn>
attribute must return the associated {{NamedNodeMap}}.

The <dfn method for="Element">getAttribute(<var>name</var>)</dfn> method must run these steps:
<ol>
 <li>Let <var>attr</var> be the result of
 <a lt="get an attribute by name">getting an attribute</a> given
 <var>name</var> and the <a>context object</a>.

 <li>If <var>attr</var> is null, return null.

 <li>Return <var>attr</var>'s <a for=Attr>value</a>.
</ol>

The
<dfn method for="Element">getAttributeNS(<var>namespace</var>, <var>localName</var>)</dfn>
method must run the following steps:

<ol>
  <li>Let <var>attr</var> be the result of
  <a lt="get an attribute by namespace and local name">getting an attribute</a>
  given <var>namespace</var>, <var>localName</var>, and the
  <a>context object</a>.

  <li>If <var>attr</var> is null, return null.

  <li>Return <var>attr</var>'s <a for=Attr>value</a>.
</ol>

The
<dfn method for="Element">setAttribute(<var>name</var>, <var>value</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>name</var> does not match the
 <code><a type>Name</a></code> production in XML,
 <a>throw</a> an
 {{InvalidCharacterError}} exception.

 <li>Let <var>attribute</var> be the result of
 <a lt="get an attribute by name">getting an attribute</a> given
 <var>name</var> and the <a>context object</a>.

 <li>If <var>attribute</var> is null, create an
 <a>attribute</a> whose
 <a for="Attr">local name</a> is <var>name</var> and
 <a for=Attr>value</a> is <var>value</var>,
 <a lt="append an attribute">append</a> this
 <a>attribute</a> to the <a>context object</a>'s
 <a for=Element>attribute list</a>, and then terminate these
 steps.

 <li><a lt="change an attribute">Change</a>
 <var>attribute</var> from <a>context object</a> to
 <var>value</var>.
</ol>

The
<dfn method for="Element">setAttributeNS(<var>namespace</var>, <var>name</var>, <var>value</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>namespace</var>, <var>prefix</var>, <var>localName</var>, and
 <var>name</var> be the result of passing <var>namespace</var> and <var>name</var> to
 <a>validate and extract</a>. Rethrow any exceptions.

 <li><a>Set an attribute value</a>
 for the <a>context object</a> using
 <var>localName</var>, <var>value</var>, and also
 <var>name</var>, <var>prefix</var>, and
 <var>namespace</var>.
</ol>

The
<dfn method for="Element">removeAttribute(<var>name</var>)</dfn>
method must
<a lt="remove an attribute by name">remove an attribute</a> given
<var>name</var> and the <a>context object</a>, and then return undefined.

The
<dfn method for="Element">removeAttributeNS(<var>namespace</var>, <var>localName</var>)</dfn>
method must
<a lt="remove an attribute by namespace and local name">remove an attribute</a>
given <var>namespace</var>, <var>localName</var>, and the
<a>context object</a>, and then return undefined.

The
<dfn method for="Element">hasAttribute(<var>name</var>)</dfn>
method must run these steps:
<ol>
 <li>If the <a>context object</a> is in the
 <a>HTML namespace</a> and its
 <a>node document</a> is an
 <a>HTML document</a>, let <var>name</var> be
 <a>converted to ASCII lowercase</a>.

 <li>Return true if the <a>context object</a>
 <a lt="has an attribute">has</a> an
 <a>attribute</a> whose
 <a for=Attr>name</a> is
 <var>name</var>, and false otherwise.
</ol>

The
<dfn method for="Element">hasAttributeNS(<var>namespace</var>, <var>localName</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>namespace</var> is the empty string, set it to null.

 <li>Return true if the <a>context object</a>
 <a lt="has an attribute">has</a> an
 <a>attribute</a> whose
 <a for="Attr">namespace</a> is <var>namespace</var>
 and <a for="Attr">local name</a> is
 <var>localName</var>, and false otherwise.
</ol>

<hr>

The
<dfn method for="Element">getAttributeNode(<var>name</var>)</dfn>
method, when invoked, must return the result of
<a lt="get an attribute by name">getting an attribute</a> given
<var>name</var> and the <a>context object</a>.

The
<dfn method for="Element">getAttributeNodeNS(<var>namespace</var>, <var>localName</var>)</dfn>
method, when invoked, must return the result of
<a lt="get an attribute by namespace and local name">getting an attribute</a> given
<var>namespace</var>, <var>localName</var>, and the <a>context object</a>.

The
<dfn method for="Element">setAttributeNode(<var>attr</var>)</dfn>
method, when invoked, must return the result of
<a lt="set an attribute">setting an attribute</a> given
<var>attr</var> and the <a>context object</a>. Rethrow any exceptions.

The
<dfn method for="Element">setAttributeNodeNS(<var>attr</var>)</dfn>
method, when invoked, must return the result of
<a lt="set an attribute">setting an attribute</a> given
<var>attr</var>, the <a>context object</a>, and
<i>namespace and local name flag</i> set. Rethrow any exceptions.

The
<dfn method for="Element">removeAttributeNode(<var>attr</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>If <var>attr</var> is not in <a>context object</a>'s
 <a for=Element>attribute list</a>,
 <a>throw</a> a {{NotFoundError}} exception.

 <li><a lt="remove an attribute">Remove</a> <var>attr</var>
 from <a>context object</a>.

 <li>Return <var>attr</var>.
</ol>

<hr>

<dl class=domintro>
 <dt><code><var>element</var> . {{closest(<var>selectors</var>)}}</code>
 <dd>Returns the first (starting at <var>element</var>)
 <a>inclusive ancestor</a> that matches
 <var>selectors</var>, and null otherwise.

 <dt><code><var>element</var> . {{matches(<var>selectors</var>)}}</code>
 <dd>Returns true if matching <var>selectors</var> against
 <var>element</var>'s <a for=tree>root</a> yields
 <var>element</var>, and false otherwise.
</dl>

The <dfn method for="Element">closest(<var>selectors</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>Let <var>s</var> be the result of
 <a>parse a selector</a> from <var>selectors</var>.
 [[!SELECTORS4]]

 <li>If <var>s</var> is failure, <a>throw</a> a
 {{SyntaxError}}.

 <li>Let <var>elements</var> be <a>context object</a>'s
 <a>inclusive ancestors</a> that are
 <a>elements</a>, in reverse
 <a>tree order</a>.

 <li>For each <var>element</var> in <var>elements</var>, if
 <a>match a selector against an element</a>, using
 <var>s</var>, <var>element</var>, and
 <a>:scope element</a> <a>context object</a>,
 returns success, return <var>element</var>. [[!SELECTORS4]]

 <li>Return null.
</ol>

The <dfn method for="Element">matches(<var>selectors</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>Let <var>s</var> be the result of
 <a>parse a selector</a> from <var>selectors</var>.
 [[!SELECTORS4]]

 <li>If <var>s</var> is failure, <a>throw</a> a
 {{SyntaxError}}.

 <li>Return true if the result of
 <a>match a selector against an element</a>, using
 <var>s</var>, <var>element</var>, and
 <a>:scope element</a> <a>context object</a>,
 returns success, and false otherwise. [[!SELECTORS4]]
</ol>

<hr>

The
<dfn method for="Element">getElementsByTagName(<var>localName</var>)</dfn>
method must return the
<a>list of elements with local name <var>localName</var></a>
for the <a>context object</a>.

The
<dfn method for="Element">getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</dfn>
method must return the
<a>list of elements with namespace <var>namespace</var> and local name <var>localName</var></a>
for the <a>context object</a>.

The
<dfn method for="Element">getElementsByClassName(<var title>classNames</var>)</dfn>
method must return the
<a>list of elements with class names <var>classNames</var></a>
for the <a>context object</a>.


<h4 id='interface-namednodemap'>Interface {{NamedNodeMap}}</h4>

<pre class=idl>
[Exposed=Window]
interface NamedNodeMap {
  readonly attribute unsigned long length;
  getter Attr? item(unsigned long index);
  getter Attr? getNamedItem(DOMString name);
  Attr? getNamedItemNS(DOMString? namespace, DOMString localName);
  Attr? setNamedItem(Attr attr);
  Attr? setNamedItemNS(Attr attr);
  Attr removeNamedItem(DOMString name);
  Attr removeNamedItemNS(DOMString? namespace, DOMString localName);
};
</pre>

A {{NamedNodeMap}} has an associated
<dfn id=concept-NamedNodeMap-element for=NamedNodeMap lt="NamedNodeMap element">element</dfn> (an
<a>element</a>).

A {{NamedNodeMap}} object's
<dfn id=concept-NamedNodeMap-attribute for=NamedNodeMap>attribute list</dfn> is its
<a for=NamedNodeMap lt="NamedNodeMap element">element</a>'s
<a for=Element>attribute list</a>.

<hr>

A {{NamedNodeMap}} object's
<a>supported property indices</a> are the numbers in the
range zero to the number of <a>attributes</a> in its
<a for=NamedNodeMap>attribute list</a> map minus one, unless the
<a for=NamedNodeMap>attribute list</a> is empty, in which case
there are no <a>supported property indices</a>.

The <dfn attribute for="NamedNodeMap">length</dfn> attribute's getter
must return the number of <a>attributes</a> in the
<a for=NamedNodeMap>attribute list</a>.

The
<dfn method for="NamedNodeMap">item(<var>index</var>)</dfn> method,
when invoked, must run these steps:

<ol>
 <li>If <var>index</var> is equal to or greater than the number of
 <a>attributes</a> in the
 <a for=NamedNodeMap>attribute list</a>, return null.

 <li>Otherwise, return the <var>index</var>th
 <a>attribute</a> in the
 <a for=NamedNodeMap>attribute list</a>.
</ol>

A {{NamedNodeMap}} object's
<a>supported property names</a>, all
<a>unenumerable</a>, are the
<a for=Attr>names</a> of the
<a>attributes</a> in the
<a for=NamedNodeMap>attribute list</a>, in order.

The
<dfn method for="NamedNodeMap">getNamedItem(<var>name</var>)</dfn>
method, when invoked, must return the result of
<a lt="get an attribute by name">getting an attribute</a> given
<var>name</var> and <a for=NamedNodeMap lt="NamedNodeMap element">element</a>.

The
<dfn method for="NamedNodeMap">getNamedItemNS(<var>namespace</var>, <var>localName</var>)</dfn>
method, when invoked, must return the result of
<a lt="get an attribute by namespace and local name">getting an attribute</a> given
<var>namespace</var>, <var>localName</var>, and
<a for=NamedNodeMap lt="NamedNodeMap element">element</a>.

The
<dfn method for="NamedNodeMap">setNamedItem(<var>attr</var>)</dfn>
method, when invoked, must return the result of
<a lt="set an attribute">setting an attribute</a> given
<var>attr</var> and <a for=NamedNodeMap lt="NamedNodeMap element">element</a>. Rethrow
any exceptions.

The
<dfn method for="NamedNodeMap">setNamedItemNS(<var>attr</var>)</dfn>
method, when invoked, must return the result of
<a lt="set an attribute">setting an attribute</a> given
<var>attr</var>, <a for=NamedNodeMap lt="NamedNodeMap element">element</a>, and
<i>namespace and local name flag</i> set. Rethrow any exceptions.

The
<dfn method for="NamedNodeMap">removeNamedItem(<var>name</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>Let <var>attr</var> be the result of
 <a lt="remove an attribute by name">removing an attribute</a> given
 <var>name</var> and <a for=NamedNodeMap lt="NamedNodeMap element">element</a>.

 <li>If <var>attr</var> is null, <a>throw</a> a
 {{NotFoundError}} exception.

 <li>Return <var>attr</var>.
</ol>

The
<dfn method for="NamedNodeMap">removeNamedItemNS(<var>namespace</var>, <var>localName</var>)</dfn>
method, when invoked, must run these steps:

<ol>
 <li>Let <var>attr</var> be the result of
 <a lt="remove an attribute by namespace and local name">removing an attribute</a>
 given <var>namespace</var>, <var>localName</var>, and
 <a for=NamedNodeMap lt="NamedNodeMap element">element</a>.

 <li>If <var>attr</var> is null, <a>throw</a> a
 {{NotFoundError}} exception.

 <li>Return <var>attr</var>.
</ol>


<h4 id='interface-attr'>Interface {{Attr}}</h4>

<pre class=idl>
[Exposed=Window]
interface Attr {
  readonly attribute DOMString? namespaceURI;
  readonly attribute DOMString? prefix;
  readonly attribute DOMString localName;
  readonly attribute DOMString name;
           attribute DOMString value;
           attribute DOMString nodeValue; // legacy alias of .value
           attribute DOMString textContent; // legacy alias of .value

  readonly attribute Element? ownerElement;

  readonly attribute boolean specified; // useless; always returns true
};</pre>


{{Attr}} objects are simply known as
<dfn id=concept-attribute lt="attribute">attributes</dfn>. They are sometimes referred
to as <em>content attributes</em> to avoid confusion with IDL attributes.

<a>Attributes</a> have a
<dfn id=concept-attribute-namespace for=Attr>namespace</dfn> (null or a non-empty string),
<dfn id=concept-attribute-namespace-prefix for=Attr>namespace prefix</dfn> (null or a non-empty string),
<dfn id=concept-attribute-local-name for=Attr>local name</dfn> (a non-empty string),
<dfn id=concept-attribute-name for=Attr>name</dfn> (a non-empty string),
<dfn id=concept-attribute-value for=Attr>value</dfn> (a string), and
<dfn id=concept-attribute-element for=Attr lt="attribute element">element</dfn> (null or an
<a>element</a>).

Note: If designed today they would just have a name and value. ☹

When an <a>attribute</a> is created, its
<a for=Attr>local name</a> is given. Unless explicitly
given when an <a>attribute</a> is created, its
<a for=Attr>name</a> is set to its
<a for=Attr>local name</a>, its
<a for=Attr>namespace</a>,
<a for=Attr>namespace prefix</a>, and
<a for=Attr lt="attribute element">element</a> are set to null, and its
<a for=Attr>value</a> is set to the empty string.

An
<dfn id=concept-named-attribute lt="named attribute"><code><var>A</var></code> attribute</dfn>
is an <a>attribute</a> whose
<a for=Attr>local name</a> is
<code><var>A</var></code> and whose
<a for=Attr>namespace</a> and
<a for=Attr>namespace prefix</a> are
null.

<hr>

The <dfn attribute for="Attr">namespaceURI</dfn>
attribute's getter must return the
<a for=Attr>namespace</a>.

The <dfn attribute for="Attr">prefix</dfn> attribute's getter must return
the <a for=Attr>namespace prefix</a>.

The <dfn attribute for="Attr">localName</dfn> attribute's getter must
return the <a for=Attr>local name</a>.

The <dfn attribute for="Attr">name</dfn> attribute's getter must return the
<a for=Attr>name</a>.

The <dfn attribute for="Attr">value</dfn> attribute's getter,
<dfn attribute for="Attr">nodeValue</dfn> attribute's getter, and
<dfn attribute for="Attr">textContent</dfn> attribute's getter, must
return the <a for=Attr>value</a>.

The {{Attr/value}} attribute's setter,
{{Attr/nodeValue}} attribute's setter, and
{{Attr/textContent}} attribute's setter, must run these
steps:

<ol>
 <li>If <a>context object</a>'s
 <a for=Attr lt="attribute element">element</a> is null, set
 <a>context object</a>'s <a for=Attr>value</a> to the
 given value.

 <li>Otherwise, <a lt="change an attribute">change</a> the
 <a>context object</a> from <a>context object</a>'s
 <a for=Attr lt="attribute element">element</a> to the given value.
</ol>

Note: Unlike with <a>node</a>'s
{{Node/textContent}}, no special null handling is required
here.

<hr>

The <dfn attribute for="Attr">ownerElement</dfn> attribute's getter
must return the <a for=Attr lt="attribute element">element</a>.

<hr>

The <dfn attribute for="Attr">specified</dfn> attribute's getter must
return true.


<h3 id='interface-characterdata'>Interface {{CharacterData}}</h3>

<pre class=idl>
[Exposed=Window]
interface CharacterData : Node {
  [TreatNullAs=EmptyString] attribute DOMString data;
  readonly attribute unsigned long length;
  DOMString substringData(unsigned long offset, unsigned long count);
  void appendData(DOMString data);
  void insertData(unsigned long offset, DOMString data);
  void deleteData(unsigned long offset, unsigned long count);
  void replaceData(unsigned long offset, unsigned long count, DOMString data);
};
</pre>

<p class="note">{{CharacterData}} is an abstract interface and does
not exist as <a>node</a>. It is used by
{{Text}}, {{Comment}}, and
{{ProcessingInstruction}} <a>nodes</a>.

Each <a>node</a> inheriting from the
{{CharacterData}} interface has an associated mutable string
called <dfn id=concept-CD-data for="CharacterData, Text, Comment, ProcessingInstruction">data</dfn>.

To <dfn id=concept-CD-replace>replace data</dfn> of node
<var>node</var> with offset <var>offset</var>, count
<var>count</var>, and data <var>data</var>, run these steps:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s
 {{CharacterData/length}} attribute value.

 <li>If <var>offset</var> is greater than <var>length</var>,
 <a>throw</a> an
 {{IndexSizeError}} exception.

 <li>If <var>offset</var> plus <var>count</var> is greater
 than <var>length</var> let <var>count</var> be
 <var>length</var> minus <var>offset</var>.

 <li><a>Queue a mutation record</a> of "<code>characterData</code>"
 for <var>node</var> with oldValue <var>node</var>'s
 <a>data</a>.

 <li>Insert <var>data</var> into <var>node</var>'s
 <a>data</a> after <var>offset</var>
 <a>code units</a>.

 <li>Let <var>delete offset</var> be <var>offset</var> plus
 the number of
 <a>code units</a> in
 <var>data</var>.

 <li>Starting from <var>delete offset</var>
 <a>code units</a>, remove
 <var>count</var>
 <a>code units</a> from
 <var>node</var>'s <a>data</a>.

 <!-- ranges -->
 <li>For each <a>range</a> whose
 <a>start node</a> is
 <var>node</var> and
 <a>start offset</a> is greater than
 <var>offset</var> but less than or equal to <var>offset</var>
 plus <var>count</var>, set its
 <a>start offset</a> to
 <var>offset</var>.

 <li>For each <a>range</a> whose
 <a>end node</a> is
 <var>node</var> and
 <a>end offset</a> is greater than
 <var>offset</var> but less than or equal to <var>offset</var>
 plus <var>count</var>, set its
 <a>end offset</a> to
 <var>offset</var>.

 <li>For each <a>range</a> whose
 <a>start node</a> is
 <var>node</var> and
 <a>start offset</a> is greater than
 <var>offset</var> plus <var>count</var>, increase its
 <a>start offset</a> by the number of
 <a>code units</a> in
 <var>data</var>, then decrease it by <var>count</var>.

 <li>For each <a>range</a> whose
 <a>end node</a> is
 <var>node</var> and
 <a>end offset</a> is greater than
 <var>offset</var> plus <var>count</var>, increase its
 <a>end offset</a> by the number of
 <a>code units</a> in
 <var>data</var>, then decrease it by <var>count</var>.
</ol>
<!-- delete happens after insert for better cursor positioning with editing
https://www.w3.org/Bugs/Public/show_bug.cgi?id=13153 -->

<!-- If you set a node's data to a new value (e.g., using the data
attribute):

IE 9: Acts like the node was deleted and recreated, moves the boundary
points up to the parent
Firefox 4: Resets the offset to 0, always
Chrome 11 dev: Resets the offset to 0, except it does nothing if the new
data is the same as the old data
Opera 11: Sets a start offset to 0 and an end offset to the end of the
data, always

The spec originally followed WebKit, since it seemed to make the most sense.
Opera's approach of setting end offsets to the length of the new data
arguably makes more sense, but that's debatable, and it's greatly
outnumbered. However, after some feedback by bzbarsky that checking for
equality is expensive, I removed the special case and matched Firefox:

https://www.w3.org/Bugs/Public/show_bug.cgi?id=13250

Authors who want WebKit-like behavior can always use replaceData() instead.

XXX replaceData is the same as setting data these days -->


To <dfn id=concept-CD-substring>substring data</dfn> with node
<var>node</var>, offset <var>offset</var>, and count
<var>count</var>, run these steps:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s
 {{CharacterData/length}} attribute value.

 <li>If <var>offset</var> is greater than <var>length</var>,
 <a>throw</a> an
 {{IndexSizeError}} exception.

 <li>If <var>offset</var> plus <var>count</var> is
 greater than <var>length</var>, return a string whose value is the
 <a>code units</a> from the
 <var>offset</var><sup>th</sup>
 <a>code unit</a> to the end of
 <var>node</var>'s <a>data</a>, and then
 terminate these steps.

 <li>Return a string whose value is the
 <a>code units</a> from the
 <var>offset</var><sup>th</sup>
 <a>code unit</a> to the
 <var>offset</var>+<var>count</var><sup>th</sup>
 <a>code unit</a> in <var>node</var>'s
 <a>data</a>.
</ol>

The <dfn attribute for="CharacterData">data</dfn> attribute
must return <a>data</a>, and on setting, must
<a>replace data</a> with node
<a>context object</a> offset 0, count
{{CharacterData/length}} attribute value, and data
new value.

The <dfn attribute for="CharacterData">length</dfn>
attribute must return the number of
<a>code units</a> in
<a>data</a>.

The
<dfn method for="CharacterData">substringData(<var>offset</var>, <var>count</var>)</dfn>
method must <a>substring data</a> with node
<a>context object</a>, offset <var>offset</var>, and count
<var>count</var>.

The
<dfn method for="CharacterData">appendData(<var>data</var>)</dfn>
method must <a>replace data</a> with node
<a>context object</a>, offset
{{CharacterData/length}} attribute value, count 0,
and data <var>data</var>.

The
<dfn method for="CharacterData">insertData(<var>offset</var>, <var>data</var>)</dfn>
method must <a>replace data</a> with node
<a>context object</a>, offset <var>offset</var>, count 0, and
data <var>data</var>.

The
<dfn method for="CharacterData">deleteData(<var>offset</var>, <var>count</var>)</dfn>
method must <a>replace data</a> with node
<a>context object</a>, offset <var>offset</var>, count
<var>count</var>, and data the empty string.

The
<dfn method for="CharacterData">replaceData(<var>offset</var>, <var>count</var>, <var>data</var>)</dfn>
method must <a>replace data</a> with node
<a>context object</a>, offset <var>offset</var>, count
<var>count</var>, and data <var>data</var>.


<h3 id='interface-text'>Interface {{Text}}</h3>

<pre class=idl>
[Constructor(optional DOMString data = ""),
 Exposed=Window]
interface Text : CharacterData {
  [NewObject] Text splitText(unsigned long offset);
  readonly attribute DOMString wholeText;
};</pre>


<dl class=domintro>
 <dt><code><var>text</var> = new <a constructor lt=Text()>Text([<var>data</var> = ""])</a></code>
 <dd>Returns a new {{Text}} <a>node</a> whose
 <a>data</a> is <var>data</var>.

 <dt><code><var>text</var> . {{splitText(<var>offset</var>)}}</code>
 <dd>Splits <a>data</a> at the given
 <var>offset</var> and returns the remainder as {{Text}}
 <a>node</a>.

 <dt><code><var>text</var> . {{Text/wholeText}}</code>
 <dd>Returns the combined <a>data</a> of all direct
 {{Text}} <a>node</a>
 <a>siblings</a>.
</dl>

The <dfn constructor for=Text>Text(<var>data</var>)</dfn> constructor
must return a new {{Text}} <a>node</a> whose
<a>data</a> is <var>data</var> and
<a>node document</a> is the global object's associated
<a>document</a>.

To <dfn id=concept-Text-split lt="split a Text node">split</dfn> a {{Text}}
<a>node</a> <var>node</var> with offset
<var>offset</var>, run these steps:

<ol>
 <li>Let <var>length</var> be <var>node</var>'s
 {{CharacterData/length}} attribute value.

 <li>If <var>offset</var> is greater than <var>length</var>,
 <a>throw</a> an
 {{IndexSizeError}} exception.

 <li>Let <var>count</var> be <var>length</var> minus
 <var>offset</var>.

 <li>Let <var>new data</var> be the result of
 <a lt="substring data">substringing data</a> with node
 <var>node</var>, offset <var>offset</var>, and count
 <var>count</var>.

 <li>Let <var>new node</var> be a new {{Text}}
 <a>node</a>, with the same
 <a>node document</a> as
 <var>node</var>. Set <var>new node</var>'s
 <a>data</a> to <var>new data</var>.

 <li>Let <var>parent</var> be <var>node</var>'s
 <a>parent</a>.

 <li>
  If <var>parent</var> is not null, run these substeps:

  <ol>
   <li><a for="node">Insert</a>
   <var>new node</var> into <var>parent</var> before
   <var>node</var>'s
   <a>next sibling</a>.
   <!-- Do this before we replace data, so that the data replacement won't
   mutate ranges prematurely:
   https://www.w3.org/Bugs/Public/show_bug.cgi?id=15325 -->

   <li>For each <a>range</a> whose
   <a>start node</a> is
   <var>node</var> and
   <a>start offset</a> is greater than
   <var>offset</var>, set its
   <a>start node</a> to
   <var>new node</var> and decrease its
   <a>start offset</a> by
   <var>offset</var>.

   <li>For each <a>range</a> whose
   <a>end node</a> is
   <var>node</var> and
   <a>end offset</a> is greater than
   <var>offset</var>, set its
   <a>end node</a> to
   <var>new node</var> and decrease its
   <a>end offset</a> by
   <var>offset</var>.

   <!-- This shit is complicated:
        https://www.w3.org/Bugs/Public/show_bug.cgi?id=19968 -->
   <li>For each <a>range</a> whose
   <a>start node</a> is
   <var>parent</var> and
   <a>start offset</a> is equal to
   the <a>index</a> of
   <var>node</var> + 1, increase its
   <a>start offset</a> by one.

   <li>For each <a>range</a> whose
   <a>end node</a> is
   <var>parent</var> and
   <a>end offset</a> is equal to
   the <a>index</a> of
   <var>node</var> + 1, increase its
   <a>end offset</a> by one.
  </ol>

 <li><a>Replace data</a> with node
 <var>node</var>, offset <var>offset</var>, count
 <var>count</var>, and data the empty string.

 <li>
  If <var>parent</var> is null, run these substeps:

  <ol>
   <li>For each <a>range</a> whose
   <a>start node</a> is
   <var>node</var> and
   <a>start offset</a> is greater
   than <var>offset</var>, set its
   <a>start offset</a> to
   <var>offset</var>.

   <li>For each <a>range</a> whose
   <a>end node</a> is
   <var>node</var> and
   <a>end offset</a> is greater than
   <var>offset</var>, set its
   <a>end offset</a> to
   <var>offset</var>.
  </ol>

 <li>Return <var>new node</var>.
</ol>

The
<dfn method for="Text">splitText(<var>offset</var>)</dfn>
method must <a lt="split a Text node">split</a> the
<a>context object</a> with offset <var>offset</var>.


The <dfn>contiguous {{Text}} nodes</dfn> of a node are the node
itself, the
<a>previous sibling</a>
{{Text}} node (if any) and its
<a>contiguous <code>Text</code> nodes</a>, and the
<a>next sibling</a> {{Text}}
node (if any) and its <a>contiguous <code>Text</code> nodes</a>,
avoiding any duplicates.

The <dfn attribute for="Text">wholeText</dfn>
attribute must return a concatenation of the
<a>data</a> of the
<a>contiguous <code>Text</code> nodes</a> of the
<a>context object</a>, in
<a>tree order</a>.



<h3 id='interface-processinginstruction'>Interface {{ProcessingInstruction}}</h3>

<pre class=idl>
[Exposed=Window]
interface ProcessingInstruction : CharacterData {
  readonly attribute DOMString target;
};</pre>


{{ProcessingInstruction}} <a>nodes</a>
have an associated <dfn id=concept-PI-target lt="PI target">target</dfn>.

The <dfn attribute for="ProcessingInstruction">target</dfn>
attribute must return the <a lt="PI target">target</a>.



<h3 id='interface-comment'>Interface {{Comment}}</h3>

<pre class=idl>
[Constructor(optional DOMString data = ""),
 Exposed=Window]
interface Comment : CharacterData {
};
</pre>

<dl class=domintro>
s <dt><code><var>comment</var> = new <a constructor lt="Comment()">Comment([<var>data</var> = ""])</a></code>
 <dd>Returns a new {{Comment}} <a>node</a> whose
 <a>data</a> is <var>data</var>.
</dl>

The <dfn constructor for=Comment>Comment(<var>data</var>)</dfn>
constructor must return a new {{Comment}} <a>node</a>
whose <a>data</a> is <var>data</var> and
<a>node document</a> is the global object's associated
<a>document</a>.




<h2 id='ranges'>Ranges</h2>

<h3 id='introduction-to-dom-ranges'>
Introduction to "DOM Ranges"</h3>

A {{Range}} object (<a>range</a>)
represents a sequence of content within a
<a>node tree</a>. Each
<a>range</a> has a
<a>start</a> and an
<a>end</a> which are
<a>boundary points</a>. A
<a>boundary point</a> is a tuple consisting of
a <a>node</a> and a non-negative numeric
<a for="boundary point">offset</a>. So in other words, a
<a>range</a> represents a piece of content within
a <a>node tree</a> between two
<a>boundary points</a>.

<a>Ranges</a> are frequently used in editing
for selecting and copying content.

<ul class="domTree">
 <li class="t1">{{Element}}: <code>p</code>
  <ul>
   <li class="t1">{{Element}}: <code class='lang-markup'>&lt;img src="insanity-wolf" alt="Little-ending BOM; decode as big-endian!"></code>
   <li class="t3">{{Text}}: <span>&nbsp;CSS 2.1 syndata is&nbsp;</span>
   <li class="t1">{{Element}}: <code class='lang-markup'>&lt;em></code>
    <ul>
     <li class="t3">{{Text}}: <span>awesome</span>
    </ul>
   <li class="t3">{{Text}}: <span>!</span>
  </ul>
</ul>
<!-- http://w3cmemes.tumblr.com/post/35332222321/css-2-1-syndata-is-awesome -->

In the <a>node tree</a> above, a
<a>range</a> can be used to represent the sequence
“syndata is awes”. Assuming <var>p</var> is assigned to the
<code>p</code> <a>element</a>, and
<var>em</var> to the <code>em</code>
<a>element</a>, this would be done as follows:

<pre class='lang-javascript'><code>
var range = new Range(),
    firstText = p.childNodes[1],
    secondText = em.firstChild
range.setStart(firstText, 9) // do not forget the leading space
range.setEnd(secondText, 4)
// range now stringifies to the aforementioned quote
</code></pre>

Note: <a>Attributes</a> such as
<code>src</code> and <code>alt</code> in the
<a>node tree</a> above cannot be represented
by a <a>range</a>. The
<a>ranges</a> concept is only useful for
<a>nodes</a>.

<a>Ranges</a> are affected by mutations to the
<a>node tree</a>. Such mutations will not
invalidate a <a>range</a> and will try to ensure
that the <a>range</a> still represents the same
piece of content. Necessarily, a <a>range</a>
might itself be modified as part of the mutation to the
<a>node tree</a> when e.g. part of the content
it represents is mutated.

Note: See the <a for="node">insert</a> and
<a>remove</a> algorithms, the
{{Node/normalize()}} method, and the
<a>replace data</a> and
<a lt="split a Text node">split</a> algorithms for the hairy
details.


<h3 id='interface-range'>
Interface {{Range}}</h3>

<pre class=idl>
[Constructor,
 Exposed=Window]
interface Range {
  readonly attribute Node startContainer;
  readonly attribute unsigned long startOffset;
  readonly attribute Node endContainer;
  readonly attribute unsigned long endOffset;
  readonly attribute boolean collapsed;
  readonly attribute Node commonAncestorContainer;

  void setStart(Node node, unsigned long offset);
  void setEnd(Node node, unsigned long offset);
  void setStartBefore(Node node);
  void setStartAfter(Node node);
  void setEndBefore(Node node);
  void setEndAfter(Node node);
  void collapse(optional boolean toStart = false);
  void selectNode(Node node);
  void selectNodeContents(Node node);

  const unsigned short START_TO_START = 0;
  const unsigned short START_TO_END = 1;
  const unsigned short END_TO_END = 2;
  const unsigned short END_TO_START = 3;
  short compareBoundaryPoints(unsigned short how, Range sourceRange);

  void deleteContents();
  [NewObject] DocumentFragment extractContents();
  [NewObject] DocumentFragment cloneContents();
  void insertNode(Node node);
  void surroundContents(Node newParent);

  [NewObject] Range cloneRange();
  void detach();

  boolean isPointInRange(Node node, unsigned long offset);
  short comparePoint(Node node, unsigned long offset);

  boolean intersectsNode(Node node);

  stringifier;
};
</pre>

{{Range}} objects are simply known as
<dfn id=concept-range lt="range">ranges</dfn>.

A <dfn for=range id=concept-range-bp>boundary point</dfn> is a
(<a>node</a>,
<dfn id=concept-range-bp-offset for="boundary point">offset</dfn>) tuple, where
<a for="boundary point">offset</a> is a non-negative
integer.

Note: Generally speaking, a
<a>boundary point</a>'s
<a for="boundary point">offset</a> will be between zero and
the <a>boundary point</a>'s
<a>node</a>
<a>length</a>, inclusive. Algorithms that
modify a <a>tree</a> (in particular the
<a for="node">insert</a>,
<a>remove</a>,
<a>replace data</a>, and
<a lt="split a Text node">split</a> algorithms) also modify
<a>ranges</a> associated with that
<a>tree</a>.

If the two <a>nodes</a> of
<a>boundary points</a>
(<var>node A</var>, <var>offset A</var>) and
(<var>node B</var>, <var>offset B</var>) have the same
<a for=tree>root</a>, the
<dfn id=concept-range-bp-position for="range">position</dfn> of the first relative to
the second is either <dfn id=concept-range-bp-before for="range">before</dfn>,
<dfn id=concept-range-bp-equal for="range">equal</dfn>, or
<dfn id=concept-range-bp-after for="range">after</dfn>,
as returned by the following algorithm:

<ol>
 <li>If <var>node A</var> is the same as <var>node B</var>,
 return <a for="range">equal</a> if
 <var>offset A</var> is the same as <var>offset B</var>,
 <a for="range">before</a> if
 <var>offset A</var> is less than <var>offset B</var>, and
 <a for="range">after</a> if
 <var>offset A</var> is greater than <var>offset B</var>.

 <li>If <var>node A</var> is
 <a>following</a>
 <var>node B</var>, compute the
 <a for="range">position</a> of
 (<var>node B</var>, <var>offset B</var>) relative to
 (<var>node A</var>, <var>offset A</var>). If it is
 <a for="range">before</a>, return
 <a for="range">after</a>. If it is
 <a for="range">after</a>, return
 <a for="range">before</a>.

 <li>
  If <var>node A</var> is an
  <a>ancestor</a> of
  <var>node B</var>:

  <ol>
   <li>Let <var>child</var> equal <var>node B</var>.

   <li>While <var>child</var> is not a
   <a>child</a> of <var>node A</var>,
   set <var>child</var> to its
   <a>parent</a>.

   <li>If the <a>index</a> of
   <var>child</var> is less than <var>offset A</var>, return
   <a for="range">after</a>.
  </ol>

 <li>Return <a for="range">before</a>.
</ol>

Each <a>range</a> has two associated
<a>boundary points</a> — a
<dfn id=concept-range-start for="range">start</dfn> and
<dfn id=concept-range-end for="range">end</dfn>.

For convenience, <dfn id=concept-range-start-node for="range">start node</dfn> is
<a>start</a>'s
<a>node</a>,
<dfn id=concept-range-start-offset for="range">start offset</dfn> is
<a>start</a>'s
<a for="boundary point">offset</a>,
<dfn id=concept-range-end-node for="range">end node</dfn> is
<a>end</a>'s
<a>node</a>,  and
<dfn id=concept-range-end-offset for="range">end offset</dfn> is
<a>end</a>'s
<a for="boundary point">offset</a>.

The <dfn id=concept-range-root for="range">root</dfn> of a
<a>range</a> is the
<a for=tree>root</a> of its
<a>start node</a>.
<!-- start and end have an identical root -->

A <a>node</a> <var>node</var> is
<dfn for="range">contained</dfn> in a <a>range</a>
<var>range</var> if <var>node</var>'s
<a for=tree>root</a> is
the same as <var>range</var>'s
<a for="range">root</a>, and (<var>node</var>, 0)
is <a for="range">after</a> <var>range</var>'s
<a>start</a>, and (<var>node</var>,
<a>length</a> of <var>node</var>) is
<a for="range">before</a> <var>range</var>'s
<a>end</a>.

A <a>node</a> is <dfn for="range">partially contained</dfn>
in a <a>range</a> if it is an
<a>inclusive ancestor</a> of the
<a>range</a>'s
<a>start node</a> but not its
<a>end node</a>, or vice versa.

<div class=note>
 Some facts to better understand these definitions:

 <ul>
  <li>The content that one would think of as being within the
  <a>range</a> consists of all
  <a>contained</a> <a>nodes</a>, plus
  possibly some of the contents of the
  <a>start node</a> and
  <a>end node</a> if those are
  {{Text}}, {{ProcessingInstruction}}, or
  {{Comment}} <a>nodes</a>.

  <li>The <a>nodes</a> that are contained in a
  <a>range</a> will generally not be contiguous,
  because the <a>parent</a> of a
  <a>contained</a> <a>node</a> will not
  always be <a>contained</a>.

  <li>However, the <a>descendants</a>
  of a <a>contained</a> <a>node</a> are
  <a>contained</a>, and if two
  <a>siblings</a> are
  <a>contained</a>, so are any
  <a>siblings</a> that lie between them.

  <li>The first <a>contained</a>
  <a>node</a> (if there are any) will always be
  after the <a>start node</a>, and the
  last <a>contained</a> <a>node</a> will
  always be equal to or before the
  <a>end node</a>'s last
  <a>descendant</a>.

  <li>The <a>start node</a> and
  <a>end node</a> of a
  <a>range</a> are never <a>contained</a>
  within it.

  <li>There exists some partially contained
  <a>node</a> if and only if the
  <a>start node</a> and
  <a>end node</a> are different.

  <li>The
  {{Range/commonAncestorContainer}}
  attribute value is never <a>contained</a> or
  <a>partially contained</a>.

  <li>If the <a>start node</a> is an
  <a>ancestor</a> of the
  <a>end node</a>, the common
  <a>inclusive ancestor</a> will
  be the <a>start node</a>. Exactly one
  of its <a>children</a> will be
  <a>partially contained</a>, and a
  <a>child</a> will be <a>contained</a>
  if and only if it <a lt="preceding">precedes</a> the
  <a>partially contained</a>
  <a>child</a>. If the
  <a>end node</a> is an
  <a>ancestor</a> of the
  <a>start node</a>, the opposite
  holds.

  <li>If the <a>start node</a> is
  not an
  <a>inclusive ancestor</a> of
  the <a>end node</a>, nor vice versa,
  the common
  <a>inclusive ancestor</a> will
  be distinct from both of them. Exactly two of its
  <a>children</a> will be
  <a>partially contained</a>, and a
  <a>child</a> will be contained if and only
  if it lies between those two.
 </ul>
</div>

<hr>

<dl class=domintro>
 <dt><code><var>range</var> = new <a constructor>Range()</a></code>
 <dd>Returns a new <a>range</a>.
</dl>

The <dfn constructor for=Range><code>Range()</code></dfn> constructor must return a new
<a>range</a> with
(global object's associated <a>document</a>, 0) as its
<a>start</a> and
<a>end</a>.

<hr>

<dl class=domintro>
 <dt><var>node</var> = <var>range</var> . {{Range/startContainer}}
 <dd>Returns <var>range</var>'s
 <a>start node</a>.

 <dt><var>offset</var> = <var>range</var> . {{Range/startOffset}}
 <dd>Returns <var>range</var>'s
 <a>start offset</a>.

 <dt><var>node</var> = <var>range</var> . {{Range/endContainer}}
 <dd>Returns <var>range</var>'s
 <a>end node</a>.

 <dt><var>offset</var> = <var>range</var> . {{Range/endOffset}}
 <dd>Returns <var>range</var>'s
 <a>end offset</a>.

 <dt><var>collapsed</var> = <var>range</var> . {{Range/collapsed}}
 <dd>Returns true if <var>range</var>'s
 <a>start</a> and
 <a>end</a> are the same, and false otherwise.

 <dt><var>container</var> = <var>range</var> . {{Range/commonAncestorContainer}}
 <dd>Returns the <a>node</a>, furthest away from
 the <a>document</a>, that is an
 <a>ancestor</a> of both
 <var>range</var>'s
 <a>start node</a> and
 <a>end node</a>.
</dl>

The <dfn attribute for="Range">startContainer</dfn>
attribute must return the
<a>start node</a>.

The <dfn attribute for="Range">startOffset</dfn>
attribute must return the
<a>start offset</a>.

The <dfn attribute for="Range">endContainer</dfn>
attribute must return the
<a>end node</a>.

The <dfn attribute for="Range">endOffset</dfn>
attribute must return the
<a>end offset</a>.

The <dfn attribute for="Range">collapsed</dfn> attribute
must return true if <a>start</a> is the same
as <a>end</a>, and false otherwise.

The
<dfn attribute for="Range">commonAncestorContainer</dfn>
attribute must run these steps:

<ol>
 <li>Let <var>container</var> be
 <a>start node</a>.

 <li>While <var>container</var> is not an
 <a>inclusive ancestor</a> of
 <a>end node</a>, let
 <var>container</var> be <var>container</var>'s
 <a>parent</a>.

 <li>Return <var>container</var>.
</ol>

<hr>

To <dfn id=concept-range-bp-set lt="set the start|set the end" for="range">set the start or end</dfn> of a
<var>range</var> to a
<a>boundary point</a>
(<var>node</var>, <var>offset</var>), run these steps:

<ol>
 <li>If <var>node</var> is a
 <a>doctype</a>,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.

 <li>If <var>offset</var> is greater than
 <var>node</var>'s <a>length</a>,
 <a>throw</a> an
 {{IndexSizeError}} exception.

 <li>Let <var>bp</var> be the
 <a>boundary point</a>
 (<var>node</var>, <var>offset</var>).

 <li>
  <dl class=switch>
   <dt>If these steps were invoked as "set the start"
   <dd>
    <ol>
     <li>If <var>bp</var> is
     <a for="range">after</a> the
     <var>range</var>'s <a>end</a>, or
     if <var>range</var>'s
     <a for="range">root</a> is not equal to
     <var>node</var>'s <a for=tree>root</a>, set
     <var>range</var>'s <a>end</a> to
     <var>bp</var>.

     <li>Set <var>range</var>'s
     <a>start</a> to <var>bp</var>.
    </ol>
   <dt>If these steps were invoked as "set the end"
   <dd>
    <ol>
     <li>If <var>bp</var> is
     <a for="range">before</a> the
     <var>range</var>'s <a>start</a>,
     or if <var>range</var>'s
     <a for="range">root</a> is not equal to
     <var>node</var>'s <a for=tree>root</a>, set
     <var>range</var>'s <a>start</a>
     to <var>bp</var>.

     <li>Set <var>range</var>'s
     <a>end</a> to <var>bp</var>.
    </ol>
  </dl>
</ol>

The
<dfn method for="Range">setStart(<var>node</var>, <var>offset</var>)</dfn>
method must <a>set the start</a> of the
<a>context object</a> to
<a>boundary point</a>
(<var>node</var>, <var>offset</var>).

The
<dfn method for="Range">setEnd(<var>node</var>, <var>offset</var>)</dfn>
method must <a>set the end</a> of the
<a>context object</a> to
<a>boundary point</a>
(<var>node</var>, <var>offset</var>).

The
<dfn method for="Range">setStartBefore(<var>node</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>parent</var> be <var>node</var>'s
 <a>parent</a>.

 <li>If <var>parent</var> is null,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.

 <li><a>Set the start</a> of the
 <a>context object</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s
 <a>index</a>).
</ol>

The
<dfn method for="Range">setStartAfter(<var>node</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>parent</var> be <var>node</var>'s
 <a>parent</a>.

 <li>If <var>parent</var> is null,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.

 <li><a>Set the start</a> of the
 <a>context object</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s
 <a>index</a> plus one).
</ol>

The
<dfn method for="Range">setEndBefore(<var>node</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>parent</var> be <var>node</var>'s
 <a>parent</a>.

 <li>If <var>parent</var> is null,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.

 <li><a>Set the end</a> of the
 <a>context object</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s <a>index</a>).
</ol>

The
<dfn method for="Range">setEndAfter(<var>node</var>)</dfn>
method must run these steps:

<ol>
 <li>Let <var>parent</var> be <var>node</var>'s
 <a>parent</a>.

 <li>If <var>parent</var> is null,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.

 <li><a>Set the end</a> of the
 <a>context object</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>node</var>'s <a>index</a> plus one).
</ol>


The
<dfn method for="Range">collapse(<var>toStart</var>)</dfn>
method must if <var>toStart</var> is true, set
<a>end</a> to
<a>start</a>, and set
<a>start</a> to
<a>end</a> otherwise.

To <dfn id=concept-range-select for="Range">select</dfn> a <a>node</a>
<var>node</var> within a <a>range</a>
<var>range</var>, run these steps:

<ol>
 <li>Let <var>parent</var> be <var>node</var>'s
 <a>parent</a>.

 <li>If <var>parent</var> is null, <a>throw</a> an
 {{InvalidNodeTypeError}}.

 <li>Let <var>index</var> be <var>node</var>'s
 <a>index</a>.

 <li>Set <var>range</var>'s <a>start</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>index</var>).

 <li>Set <var>range</var>'s <a>end</a> to
 <a>boundary point</a>
 (<var>parent</var>, <var>index</var> plus one).
</ol>

The <dfn method for="Range">selectNode(<var>node</var>)</dfn>
method must <a for=Range>select</a> <var>node</var> within
<a>context object</a>.

The <dfn method for="Range">selectNodeContents(<var>node</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>node</var> is a
 <a>doctype</a>,
 <a>throw</a> an
 {{InvalidNodeTypeError}}.

 <li>Let <var>length</var> be the
 <a>length</a> of <var>node</var>.

 <li>Set <a>start</a> to the
 <a>boundary point</a>
 (<var>node</var>, 0).

 <li>Set <a>end</a> to the
 <a>boundary point</a>
 (<var>node</var>, <var>length</var>).
</ol>

<hr>

The <dfn method for="Range">compareBoundaryPoints(<var>how</var>, <var>sourceRange</var>)</dfn>
method must run these steps:

<ol>
 <li>
  If <var>how</var> is not one of
  <ul>
   <li>{{Range/START_TO_START}},
   <li>{{Range/START_TO_END}},
   <li>{{Range/END_TO_END}}, and
   <li>{{Range/END_TO_START}},
  </ul>
  <a>throw</a> a
  {{NotSupportedError}} exception.
 <!--
 Apparent behaviors from black-box testing:

 IE9: Converts to unsigned short per WebIDL, then throws "Error: Invalid
 argument." if it's not 0-3.

 Firefox 12.0a1: Converts to unsigned short per WebIDL, then throws
 NS_ERROR_ILLEGAL_VALUE if it's not 0-3.

 Chrome 17 dev: Converts to unsigned *long* per WebIDL, and treats bad values
 as 0.  Never throws.

 Opera Next 12.00 alpha: Throws NotSupportedError unless the value is -0, 0, 1,
 2, 3, or an integer equal to one of these modulo 2^32.  (In particular, it
 throws on NaN, Infinity, and -Infinity instead of treating them as 0 per
 WebIDL.)

 The spec follows IE9/Gecko, except that we throw NotSupportedError (like
 Opera) instead of a nonstandard exception type.
 -->

 <li>If <a>context object</a>'s
 <a for="range">root</a> is not the same as
 <var>sourceRange</var>'s <a for="range">root</a>,
 <a>throw</a> a
 {{WrongDocumentError}} exception.

 <li>
  If <var>how</var> is:
  <dl class=switch>
   <dt>{{Range/START_TO_START}}:
   <dd>
    Let <var>this point</var> be the <a>context object</a>'s
    <a>start</a>.
    Let <var>other point</var> be <var>sourceRange</var>'s
    <a>start</a>.

   <dt>{{Range/START_TO_END}}:
   <dd>
    Let <var>this point</var> be the <a>context object</a>'s
    <a>end</a>.
    Let <var>other point</var> be <var>sourceRange</var>'s
    <a>start</a>.

    <dt>{{Range/END_TO_END}}:
    <dd>
     Let <var>this point</var> be the <a>context object</a>'s
     <a>end</a>.
     Let <var>other point</var> be <var>sourceRange</var>'s
     <a>end</a>.

    <dt>{{Range/END_TO_START}}:
    <dd>
     Let <var>this point</var> be the <a>context object</a>'s
     <a>start</a>.
     Let <var>other point</var> be <var>sourceRange</var>'s
     <a>end</a>.
   </dl>

  <li>
   If the <a for="range">position</a> of
   <var>this point</var> relative to <var>other point</var> is

   <dl class=switch>
    <dt><a for="range">before</a>
    <dd>Return &minus;1.

    <dt><a for="range">equal</a>
    <dd>Return 0.

    <dt><a for="range">after</a>
    <dd>Return 1.
   </dl>
</ol>

The <dfn method for="Range">deleteContents()</dfn>
method must run these steps:

<ol>
 <li>If <a>start</a> equals
 <a>end</a>, terminate these steps.
 <!-- This might actually make no difference, but it's not immediately
 obvious what would happen otherwise if the start/end were text/comment:
 are all the substeps of the next step actually no-ops, or could some have
 side effects? -->

 <li>Let <var>original start node</var>,
 <var>original start offset</var>, <var>original end node</var>,
 and <var>original end offset</var> be the
 <a>context object</a>'s
 <a>start node</a>,
 <a>start offset</a>,
 <a>end node</a>, and
 <a>end offset</a>, respectively.

 <li>If <var>original start node</var> and
 <var>original end node</var> are the same, and they are a
 {{Text}}, {{ProcessingInstruction}}, or
 {{Comment}} <a>node</a>,
 <a>replace data</a> with node
 <var>original start node</var>, offset
 <var>original start offset</var>, count
 <var>original end offset</var> minus
 <var>original start offset</var>, and data the empty string, and then
 terminate these steps.

 <li>Let <var>nodes to remove</var> be a list of all the
 <a>nodes</a> that are <a>contained</a> in
 the <a>context object</a>, in
 <a>tree order</a>, omitting any
 <a>node</a> whose
 <a>parent</a> is also
 <a>contained</a> in the <a>context object</a>.

 <li>If <var>original start node</var> is an
 <a>inclusive ancestor</a> of
 <var>original end node</var>, set
 <var>new node</var> to <var>original start node</var> and
 <var>new offset</var> to <var>original start offset</var>.

 <li>
  Otherwise:
  <ol>
   <li>Let <var>reference node</var> equal
   <var>original start node</var>.

   <li>While <var>reference node</var>'s
   <a>parent</a> is not null and is not an
   <a>inclusive ancestor</a> of
   <var>original end node</var>, set <var>reference node</var>
   to its <a>parent</a>.

   <li>
    Set <var>new node</var> to the
    <a>parent</a> of
    <var>reference node</var>, and <var>new offset</var> to one
    plus the <a>index</a> of
    <var>reference node</var>.

    Note: If <var>reference node</var>'s
    <a>parent</a> were null, it would be the
    <a for="range">root</a> of the
    <a>context object</a>, so would be an
    <a>inclusive ancestor</a> of
    <var>original end node</var>, and we could not reach this point.
  </ol>

 <li>If <var>original start node</var> is a {{Text}},
 {{ProcessingInstruction}}, or {{Comment}}
 <a>node</a>,
 <a>replace data</a> with node
 <var>original start node</var>, offset
 <var>original start offset</var>, count
 <var>original start node</var>'s
 <a>length</a> minus
 <var>original start offset</var>, data the empty string.

 <li>For each <var>node</var> in <var>nodes to remove</var>,
 in <a>tree order</a>,
 <a>remove</a> <var>node</var> from
 its <a>parent</a>.

 <li>If <var>original end node</var> is a {{Text}},
 {{ProcessingInstruction}}, or {{Comment}}
 <a>node</a>,
 <a>replace data</a> with node
 <var>original end node</var>, offset 0, count
 <var>original end offset</var> and data the empty string.

 <li>Set <a>start</a> and
 <a>end</a> to
 (<var>new node</var>, <var>new offset</var>).
</ol>

To <dfn id=concept-range-extract lt="extract a range" local-lt="extract">extract</dfn> a
<a>range</a> <var>range</var>, run these steps:

<ol>
 <li>Let <var>fragment</var> be a new {{DocumentFragment}}
 <a>node</a> whose
 <a>node document</a> is <var>range</var>'s
 <a>start node</a>'s
 <a>node document</a>.

 <li>If <var>range</var>'s <a>start</a> equals
 its <a>end</a>, return <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li>Let <var>original start node</var>, <var>original start offset</var>,
 <var>original end node</var>, and <var>original end offset</var> be
 <var>range</var>'s <a>start node</a>,
 <a>start offset</a>,
 <a>end node</a>, and
 <a>end offset</a>, respectively.

 <li>
  If <var>original start node</var> equals
  <var>original end node</var>, and they are a {{Text}},
  {{ProcessingInstruction}}, or {{Comment}}
  <a>node</a>:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original end offset</var> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li><a>Replace data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, count
   <var>original end offset</var> minus
   <var>original start offset</var>, and data the empty string.

   <li>Return <var>fragment</var>.
  </ol>

 <li>Let <var>common ancestor</var> be
 <var>original start node</var>.

 <li>While <var>common ancestor</var> is not an
 <a>inclusive ancestor</a> of
 <var>original end node</var>, set <var>common ancestor</var> to
 its own <a>parent</a>.

 <li>Let <var>first partially contained child</var> be null.

 <li>If <var>original start node</var> is <em>not</em> an
 <a>inclusive ancestor</a> of
 <var>original end node</var>, set <var>first partially contained child</var>
 to the first <a>child</a> of
 <var>common ancestor</var> that is <a>partially contained</a> in
 <var>range</var>.

 <li>Let <var>last partially contained child</var> be null.

 <li>
  If <var>original end node</var> is <em>not</em> an
  <a>inclusive ancestor</a> of
  <var>original start node</var>, set
  <var>last partially contained child</var> to the last
  <a>child</a> of <var>common ancestor</var> that is
  <a>partially contained</a> in <var>range</var>.

  Note: These variable assignments do actually always make sense.
  For instance, if <var>original start node</var> is not an
  <a>inclusive ancestor</a> of
  <var>original end node</var>, <var>original start node</var> is itself
  <a>partially contained</a> in <var>range</var>, and so are all its
  <a>ancestors</a> up until a
  <a>child</a> of <var>common ancestor</var>.
  <var>common ancestor</var> cannot be <var>original start node</var>, because
  it has to be an <a>inclusive ancestor</a> of
  <var>original end node</var>. The other case is similar. Also, notice that the two
  <a>children</a> will never be equal if both are defined.

 <li>Let <var>contained children</var> be a list of all
 <a>children</a> of
 <var>common ancestor</var> that are <a>contained</a> in
 <var>range</var>, in <a>tree order</a>.

 <li>
  If any member of <var>contained children</var> is a
  <a>doctype</a>, <a>throw</a> a
  {{HierarchyRequestError}} exception.
  <!-- Firefox 4.0 actually removes the non-DocumentType nodes before
  throwing the exception. Opera 11.00 removes the DocumentType too, and
  doesn't throw. I go with IE9 and Chrome 12 dev, which don't remove any
  nodes. DOM 2 Range doesn't specify what exactly happens here, except that
  an exception should be thrown. -->

  Note: We do not have to worry about the first or last partially
  contained node, because a <a>doctype</a> can never be
  partially contained. It cannot be a boundary point of a range, and it
  cannot be the ancestor of anything.

 <li>If <var>original start node</var> is an
 <a>inclusive ancestor</a> of
 <var>original end node</var>, set <var>new node</var> to
 <var>original start node</var> and <var>new offset</var> to
 <var>original start offset</var>.

 <li>
  Otherwise:
  <ol>
   <li>Let <var>reference node</var> equal <var>original start node</var>.

   <li>While <var>reference node</var>'s
   <a>parent</a> is not null and is not an
   <a>inclusive ancestor</a> of
   <var>original end node</var>, set <var>reference node</var> to its
   <a>parent</a>.

   <li>
    Set <var>new node</var> to the
    <a>parent</a> of <var>reference node</var>, and
    <var>new offset</var> to one plus <var>reference node</var>'s
    <a>index</a>.

    Note: If <var>reference node</var>'s
    <a>parent</a> is null, it would be the
    <a for="range">root</a> of <var>range</var>, so would be an
    <a>inclusive ancestor</a> of
    <var>original end node</var>, and we could not reach this point.
  </ol>

  <!-- Now we start with mutations, so we can't refer to the context object
  anymore unless we carefully consider how it will have mutated. -->

 <li>
  If <var>first partially contained child</var> is a
  {{Text}}, {{ProcessingInstruction}}, or
  {{Comment}} <a>node</a>:

  Note: In this case, <var>first partially contained child</var> is
  <var>original start node</var>.

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original start node</var>'s
   <a>length</a> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li><a>Replace data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, count
   <var>original start node</var>'s
   <a>length</a> minus
   <var>original start offset</var>, and data the empty string.
  </ol>

 <li>
  Otherwise, if <var>first partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>first partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>range</a>
   whose <a>start</a> is
   (<var>original start node</var>, <var>original start offset</var>) and
   whose <a>end</a> is
   (<var>first partially contained child</var>, <var>first partially contained child</var>'s <a>length</a>).

   <li>Let <var>subfragment</var> be the result of
   <a lt="extract a range">extracting</a> <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>For each <var>contained child</var> in <var>contained children</var>,
 <a>append</a> <var>contained child</var> to
 <var>fragment</var>.

 <li>
  If <var>last partially contained child</var> is a
  {{Text}}, {{ProcessingInstruction}}, or
  {{Comment}} <a>node</a>:

  Note: In this case, <var>last partially contained child</var> is
  <var>original end node</var>.

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>original end node</var>.

   <li>Set the <a>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original end node</var>, offset 0, and count
   <var>original end offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li><a>Replace data</a> with node
   <var>original end node</var>, offset 0, count
   <var>original end offset</var>, and data the empty string.
  </ol>

 <li>
  Otherwise, if <var>last partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>last partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>range</a>
   whose <a>start</a> is
   (<var>last partially contained child</var>, 0) and whose
   <a>end</a> is
   (<var>original end node</var>, <var>original end offset</var>).

   <li>Let <var>subfragment</var> be the result of
   <a lt="extract a range">extracting</a> <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>Set <var>range</var>'s <a>start</a> and
 <a>end</a> to
 (<var>new node</var>, <var>new offset</var>).

 <li>Return <var>fragment</var>.
</ol>

The <dfn method for="Range">extractContents()</dfn> method
must return the result of <a lt="extract a range">extracting</a>
<a>context object</a>.

To <dfn id=concept-range-clone lt="clone a range">clone</dfn> a <a>range</a>
<var>range</var>, run these steps:

<ol>
 <li>Let <var>fragment</var> be a new {{DocumentFragment}}
 <a>node</a> whose
 <a>node document</a> is <var>range</var>'s
 <a>start node</a>'s
 <a>node document</a>.

 <li>If <var>range</var>'s <a>start</a> equals
 its <a>end</a>, return <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li>Let <var>original start node</var>, <var>original start offset</var>,
 <var>original end node</var>, and <var>original end offset</var> be
 <var>range</var>'s <a>start node</a>,
 <a>start offset</a>,
 <a>end node</a>, and
 <a>end offset</a>, respectively.

 <li>
  If <var>original start node</var> equals
  <var>original end node</var>, and they are a {{Text}},
  {{ProcessingInstruction}}, or {{Comment}}
  <a>node</a>:

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original end offset</var> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Return <var>fragment</var>.
  </ol>

 <li>Let <var>common ancestor</var> be
 <var>original start node</var>.

 <li>While <var>common ancestor</var> is not an
 <a>inclusive ancestor</a> of
 <var>original end node</var>, set
 <var>common ancestor</var> to its own
 <a>parent</a>.

 <li>Let <var>first partially contained child</var> be null.

 <li>If <var>original start node</var> is <em>not</em> an
 <a>inclusive ancestor</a> of
 <var>original end node</var>, set <var>first partially contained child</var>
 to the first <a>child</a> of
 <var>common ancestor</var> that is <a>partially contained</a> in
 <var>range</var>.

 <li>Let <var>last partially contained child</var> be null.

 <li>
  If <var>original end node</var> is <em>not</em> an
  <a>inclusive ancestor</a> of
  <var>original start node</var>, set
  <var>last partially contained child</var> to the last
  <a>child</a> of <var>common ancestor</var> that is
  <a>partially contained</a> in <var>range</var>.

  Note: These variable assignments do actually always make sense.
  For instance, if <var>original start node</var> is not an
  <a>inclusive ancestor</a> of
  <var>original end node</var>, <var>original start node</var> is itself
  <a>partially contained</a> in <var>range</var>, and so are all its
  <a>ancestors</a> up until a
  <a>child</a> of <var>common ancestor</var>.
  <var>common ancestor</var> cannot be <var>original start node</var>, because
  it has to be an <a>inclusive ancestor</a> of
  <var>original end node</var>. The other case is similar. Also, notice that the two
  <a>children</a> will never be equal if both are defined.

 <li>Let <var>contained children</var> be a list of all
 <a>children</a> of
 <var>common ancestor</var> that are <a>contained</a> in
 <var>range</var>, in <a>tree order</a>.

 <li>
  If any member of <var>contained children</var> is a
  <a>doctype</a>, <a>throw</a> a
  {{HierarchyRequestError}} exception.

  Note: We do not have to worry about the first or last partially
  contained node, because a <a>doctype</a> can never be
  partially contained. It cannot be a boundary point of a range, and it
  cannot be the ancestor of anything.

 <li>
  If <var>first partially contained child</var> is a
  {{Text}}, {{ProcessingInstruction}}, or
  {{Comment}} <a>node</a>:

  Note: In this case, <var>first partially contained child</var> is
  <var>original start node</var>.

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>original start node</var>.

   <li>Set the <a>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original start node</var>, offset
   <var>original start offset</var>, and count
   <var>original start node</var>'s
   <a>length</a> minus
   <var>original start offset</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.
  </ol>

 <li>
  Otherwise, if <var>first partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>first partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>range</a>
   whose <a>start</a> is
   (<var>original start node</var>, <var>original start offset</var>) and
   whose <a>end</a> is
   (<var>first partially contained child</var>, <var>first partially contained child</var>'s <a>length</a>).

   <li>Let <var>subfragment</var> be the result of
   <a lt="clone a range">cloning</a> <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>
  For each <var>contained child</var> in
  <var>contained children</var>:

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>contained child</var> with the <i>clone children flag</i> set.

   <li><a>Append</a> <var>clone</var> to
   <var>fragment</var>.
  </ol>

 <li>
  If <var>last partially contained child</var> is a
  {{Text}}, {{ProcessingInstruction}}, or
  {{Comment}} <a>node</a>:

  Note: In this case, <var>last partially contained child</var> is
  <var>original end node</var>.

  <ol>
   <li>Let <var>clone</var> be a <a lt="clone a node">clone</a> of
   <var>original end node</var>.

   <li>Set the <a>data</a> of
   <var>clone</var> to the result of
   <a lt="substring data">substringing data</a> with node
   <var>original end node</var>, offset 0, and count
   <var>original end offset</var>.

   <li><a>Append</a> <var>clone</var> to
   <var>fragment</var>.
  </ol>

 <li>
  Otherwise, if <var>last partially contained child</var> is not
  null:

  <ol>
   <li>Let <var>clone</var> be a
   <a lt="clone a node">clone</a> of
   <var>last partially contained child</var>.

   <li><a>Append</a> <var>clone</var>
   to <var>fragment</var>.

   <li>Let <var>subrange</var> be a new <a>range</a>
   whose <a>start</a> is
   (<var>last partially contained child</var>, 0) and whose
   <a>end</a> is
   (<var>original end node</var>, <var>original end offset</var>).

   <li>Let <var>subfragment</var> be the result of
   <a lt="clone a range">cloning</a> <var>subrange</var>.

   <li><a>Append</a> <var>subfragment</var> to
   <var>clone</var>.
  </ol>

 <li>Return <var>fragment</var>.
</ol>

The <dfn method for="Range">cloneContents()</dfn>
method must return the result of <a lt="clone a range">cloning</a>
<a>context object</a>.

To <dfn id=concept-range-insert for="range">insert</dfn> a <a>node</a>
<var>node</var> into a <a>range</a>
<var>range</var>, run these steps:

<ol>
  <!-- Chrome 12 dev throws "HierarchyRequestError" if node is the same
  as the start node (at least for text nodes). This doesn't seem to make
  much sense, since insertBefore() works fine to move a node to its current
  position, and other browsers disagree, so the spec follows the majority.
  -->
 <li>If <var>range</var>'s <a>start node</a>
 is either a {{ProcessingInstruction}} or {{Comment}}
 <a>node</a>, or a {{Text}}
 <a>node</a> whose <a>parent</a>
 is null, <a>throw</a> an {{HierarchyRequestError}}
 exception.

 <!--
 Behavior for Text node with null parent:

 IE9: Allows it to go through, resulting in the text/comment node having a non-null previousSibling but a null parentNode. (?!)
 Firefox 4.0: Throws non-standard exception
 Chrome 12 dev: Throws "HierarchyRequestError"
 Opera 11.00: Doesn't come up, doesn't allow ranges on detached nodes

 IE is clearly crazy, and non-standard exceptions are no good, so we go with
 WebKit.

 For a Comment node, see https://www.w3.org/Bugs/Public/show_bug.cgi?id=15350.
 IE9, Firefox 12.0a1, and Chrome 17 dev all agree on throwing a
 HierarchyRequestError.  Opera Next 12.00 alpha splits the comment, same as a
 text node.
 -->
 <li>Let <var>referenceNode</var> be null.

 <li>If <var>range</var>'s <a>start node</a>
 is a {{Text}} <a>node</a>,
 set <var>referenceNode</var> to that {{Text}}
 <a>node</a>. <!-- This will change when we split
 it. -->

 <li>Otherwise, set <var>referenceNode</var> to the
 <a>child</a> of
 <a>start node</a> whose
 <a>index</a> is
 <a>start offset</a>, and null if
 there is no such <a>child</a>.

 <li>Let <var>parent</var> be <var>range</var>'s
 <a>start node</a> if <var>referenceNode</var>
 is null, and <var>referenceNode</var>'s
 <a>parent</a> otherwise.

 <!-- IE9 and Chrome 12 dev throw an exception before splitting the text
 node if the insertBefore() is going to throw an exception (at least if the
 new node is the parent of the start node, for instance). Firefox 4.0 and
 Opera 11.00 don't.  Now that we have "ensure pre-insertion validity," we go
 with the IE/Chrome behavior because it's more correct.

 IE9 doesn't call splitText() if the offset is 0. This makes sense, but I go
 with what all other browsers do. -->
 <li><a>Ensure pre-insertion validity</a>
 of <var>node</var> into <var>parent</var> before
 <var>referenceNode</var>.

 <li>If <var>range</var>'s <a>start node</a>
 is a {{Text}} <a>node</a>,
 <a lt="split a Text node">split</a> it with offset
 <var>range</var>'s <a>start offset</a>,
 set <var>referenceNode</var> to the result, and set
 <var>parent</var> to <var>referenceNode</var>'s
 <a>parent</a>.

 <li>If <var>node</var> equals <var>referenceNode</var>, set
 <var>referenceNode</var> to its
 <a>next sibling</a>. <!-- Because we're
 about to remove node from its parent. -->

 <li>If <var>node</var>'s <a>parent</a> is not
 null, <a>remove</a> <var>node</var> from its
 <a>parent</a>.

 <!-- Browsers disagree on how to handle the case where the range is
 collapsed: do you increment the end offset so the node is now included, or
 not?  DOM 2 Range says no, and Firefox 12.0a1 follows that, but IE9, Chrome
 17 dev, and Opera Next 12.00 alpha all do increment.  Apparently this
 traces back to Acid3 at one point requiring the non-standard behavior.
 Previously the spec matched DOM 2 Range, but it changed to match the
 majority of browsers.  See
 https://www.w3.org/Bugs/Public/show_bug.cgi?id=15297.

 We have to be careful here, because if node is a DocumentFragment, we might
 have inserted any number of nodes, including zero.  One corner case is if
 we insert an empty DocumentFragment and the range is collapsed in a text
 node.  In that case, the text node gets split, but browsers disagree on
 what to do with the range's end.  IE9 leaves it in place; Chrome 17 dev
 moves it to the parent element, before the reference node; Opera Next 12.00
 alpha moves it to the beginning of the new text node.  The spec follows
 WebKit just because it happens to be easier for me to spec.

 The logic for how much to increment the position by is copied from the
 "insert" algorithm.  Getting the new offset right was surprisingly tricky.
 -->
 <li>Let <var>newOffset</var> be <var>parent</var>'s
 <a>length</a> if <var>referenceNode</var> is null,
 and <var>referenceNode</var>'s <a>index</a>
 otherwise.

 <li>Increase <var>newOffset</var> by <var>node</var>'s
 <a>length</a> if <var>node</var> is a
 {{DocumentFragment}} <a>node</a>, and one otherwise.

 <li><a>Pre-insert</a>
 <var>node</var> into <var>parent</var> before <var>referenceNode</var>.

 <li>If <var>range</var>'s <a>start</a> and
 <a>end</a> are the same, set <var>range</var>'s
 <a>end</a> to
 (<var>parent</var>, <var>newOffset</var>).
</ol>

The <dfn method for="Range">insertNode(<var>node</var>)</dfn>
method must <a for="range">insert</a> <var>node</var> into
<a>context object</a>.

The
<dfn method for="Range">surroundContents(<var>newParent</var>)</dfn>
method must run these steps:

<!--
IE9 and Chrome 12 dev throw exceptions before doing any DOM mutations in at
least some cases, so they don't wind up modifying the DOM halfway. Like if you
try surrounding a selection with an ancestor. As with insertNode(), this is
slightly nicer, but Firefox 4.0 and Opera 11.00 don't do this, and their
behavior is slightly easier to spec, so I go with them for exceptions that are
thrown by things we call, like insertNode(). However, for
BAD_BOUNDARYPOINTS_ERR/INVALID_NODE_TYPE_ERR that we throw ourselves, I do the
check first thing, which matches everyone but Firefox.
-->

<ol>
 <li>If a non-{{Text}} <a>node</a> is
 <a>partially contained</a> in the <a>context object</a>,
 <a>throw</a> an
 {{InvalidStateError}} exception.
 <!-- Makes some sense: otherwise we'd clone a bunch of containers, which is
 unexpected. -->
 <!-- XXX Could we rephrase this condition to be more algorithmic and less
 declarative?-->

 <li>If <var>newParent</var> is a {{Document}},
 {{DocumentType}}, or {{DocumentFragment}}
 <a>node</a>,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.
 <!-- But for Comment, Text, and ProcessingInstruction, we just fall through
 and throw a HIERARCHY_REQUEST_ERR when we try appendChild(). This makes
 absolutely no sense, but it's what DOM 2 Range specifies, and it's what
 IE9, Chrome 12 dev, and Opera 11.00 implement. Firefox 4.0 only throws
 INVALID_NODE_TYPE_ERR on DocumentFragments, it falls through to
 HIERARCHY_REQUEST_ERR for Documents and DocumentTypes.

 Firefox 4.0 does this check later on, so it will do DOM mutations of some
 type if passed a DocumentFragment. We match IE9, Chrome 12 dev, and Opera
 11.00 in doing the check early.

 If newParent is a Document/DocumentType/DocumentFragment, and some node is
 also partially contained, DOM 2 Range doesn't say whether to throw
 BAD_BOUNDARYPOINTS_ERR or INVALID_NODE_TYPE_ERR. IE9 and Chrome 12 dev
 throw INVALID_NODE_TYPE_ERR, while Firefox 4.0 and Opera 11.00 throw
 BAD_BOUNDARYPOINTS_ERR. I chose the latter because it's the first thing I
 happened to write down and it makes no real difference, with the even
 split. -->

 <li>Let <var>fragment</var> be the result of
 <a lt="extract a range">extracting</a> <a>context object</a>.
 <!-- If the range contains a DocumentType, Firefox 4.0 and Opera 11.00 don't
 immediately throw here. Firefox removes the non-DocumentType nodes and
 throws, Opera removes all nodes and doesn't throw. This applies to
 extractContents() proper, and also affects surroundContents(). I match DOM 2
 Range, IE9, and Chrome 12 dev. -->

 <li>If <var>newParent</var> has
 <a>children</a>,
 <a>replace all</a> with null within
 <var>newParent</var>.

 <li><a for="range">Insert</a> <var>newParent</var> into
 <a>context object</a>.

 <li><a>Append</a> <var>fragment</var> to
 <var>newParent</var>.

 <li><a for=Range>Select</a> <var>newParent</var> within
 <a>context object</a>.
 <!-- Generally this isn't needed, because insertNode() will already do it,
 but it makes a difference in at least one corner case (when the original
 range lies in a single text node). -->
</ol>

The <dfn method for="Range">cloneRange()</dfn>
method must return a new <a>range</a> with the
same <a>start</a> and
<a>end</a> as the <a>context object</a>.

The <dfn method for="Range">detach()</dfn> method must
do nothing. <span class=note>Its functionality (disabling a
{{Range}} object) was removed, but the method itself is preserved
for compatibility.</span>

<hr>

<dl class=domintro>
 <dt><var>position</var> = <var>range</var> . {{Range/comparePoint( <var>parent</var>, <var>offset</var> )}}
 <dd>Returns &minus;1 if the point is before the range, 0 if the point is
 in the range, and 1 if the point is after the range.

 <dt><var>intersects</var> = <var>range</var> . {{Range/intersectsNode( <var>node</var> )}}
 <dd>Returns whether <var>range</var> intersects
 <var>node</var>.
</dl>

<div class=impl>

The
<dfn method for="Range">isPointInRange(<var>node</var>, <var>offset</var>)</dfn>
must run these steps:
<!-- Tested October 2011 on Firefox 9.0a2 and Chrome 16 dev.  IE9 and Opera
11.50 don't support the method. -->

<ol>
 <li>If <var>node</var>'s <a for=tree>root</a> is
 different from the <a>context object</a>'s <a for="range">root</a>, return false.
 <!-- This happens even if the offset is negative or too large, or if the node
 is a doctype, in both Firefox 9.0a2 and Chrome 16 dev. -->

 <li>If <var>node</var> is a
 <a>doctype</a>,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.
 <!-- Firefox 9.0a2 doesn't throw.  It ignores the offset and returns true or
 false depending on whether the doctype itself is in the range.  This makes
 some sense, but it doesn't match how other Range APIs handle doctypes, and
 having the second argument mandatory but ignored is just weird.  Thus I go
 with Chrome 16 dev, although I can see the merit in how Gecko works here. -->

 <li>If <var>offset</var> is greater than
 <var>node</var>'s <a>length</a>,
 <a>throw</a> an
 {{IndexSizeError}} exception.
 <!-- Firefox 9.0a2 doesn't throw.  It seems to return true if the node is
 completely contained in the range, like with selectNode(), and false otherwise -
 even if all boundary points in the node are contained in the range, like
 with selectNodeContents().  This is weird, and inconsistent with other Range
 APIs, so I go with Chrome 16 dev.  This is probably an authoring bug, so it's
 best to throw anyway. -->

 <li>If (<var>node</var>, <var>offset</var>) is
 <a for="range">before</a>
 <a>start</a> or
 <a for="range">after</a>
 <a>end</a>, return false.

 <li>Return true.
</ol>


The
<dfn method for="Range">comparePoint(<var>node</var>, <var>offset</var>)</dfn>
method must run these steps:
<!-- IE9 doesn't support this method at all.  Firefox 12.0a1, Chrome 17 dev,
and Opera Next 12.00 alpha all do. -->

<ol>
 <li>If <var>node</var>'s <a for=tree>root</a> is
 different from the <a>context object</a>'s
 <a for="range">root</a>,
 <a>throw</a> a {{WrongDocumentError}}
 exception.
 <!-- Opera Next 12.00 alpha seems to return -1 in this case.  The spec matches
 Firefox 12.0a1 and Chrome 17 dev. -->

 <li>If <var>node</var> is a
 <a>doctype</a>,
 <a>throw</a> an
 {{InvalidNodeTypeError}} exception.
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00
 alpha, which don't throw and seem to just ignore the offset instead.  See
 comment for isPointInRange(). -->

 <li>If <var>offset</var> is greater than
 <var>node</var>'s <a>length</a>,
 <a>throw</a> an
 {{IndexSizeError}} exception.
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00
 alpha, which don't throw.  See comment for isPointInRange(). -->

 <li>If (<var>node</var>, <var>offset</var>) is
 <a for="range">before</a>
 <a>start</a>, return &minus;1.

 <li>If (<var>node</var>, <var>offset</var>) is
 <a for="range">after</a>
 <a>end</a>, return 1.

 <li>Return 0.
</ol>

<hr>

The
<dfn method for="Range">intersectsNode(<var>node</var>)</dfn>
method must run these steps:
<!-- Supported by Chrome 17 dev and Opera Next 12.00 alpha, but not IE9 or
Firefox 12.0a1. -->

<ol>
 <li>If <var>node</var>'s <a for=tree>root</a>
 is different from the <a>context object</a>'s
 <a for="range">root</a>, return false.
 <!-- It seems like for doctypes, Opera Next 12.00 alpha throws
 InvalidNodeTypeError instead of returning false.  The spec follows Chrome
 17 dev. -->

 <li>Let <var>parent</var> be <var>node</var>'s
 <a>parent</a>.

 <li>If <var>parent</var> is null, return true.
 <!-- browsers currently throw, but are willing to change
      https://www.w3.org/Bugs/Public/show_bug.cgi?id=16759 -->

 <li>Let <var>offset</var> be <var>node</var>'s
 <a>index</a>.

 <li>If (<var>parent</var>, <var>offset</var>) is
 <a for="range">before</a>
 <a>end</a> and (<var>parent</var>,
 <var>offset</var> + 1) is
 <a for="range">after</a>
 <a>start</a>, return true.

 <li>Return false.
</ol>

</div>

<hr>

The <dfn lt=dom-Range-stringifier>stringifier</dfn> must run these
steps:

<ol>
 <li>Let <var>s</var> be the empty string.

 <li>If <a>start node</a> equals
 <a>end node</a>, and it is a
 {{Text}} <a>node</a>, return the
 substring of that {{Text}} <a>node</a>'s <a>data</a> beginning at
 <a>start offset</a> and ending at
 <a>end offset</a>.

 <li>If <a>start node</a> is a
 {{Text}} <a>node</a>, append to
 <var>s</var> the substring of that
 <a>node</a>'s
 <a>data</a> from the
 <a>start offset</a> until the end.

 <li>Append to <var>s</var> the concatenation, in
 <a>tree order</a>, of the
 <a>data</a> of all {{Text}}
 <a>nodes</a> that are <a>contained</a> in
 the <a>context object</a>.

 <li>If <a>end node</a> is a
 {{Text}} <a>node</a>, append to
 <var>s</var> the substring of that
 <a>node</a>'s
 <a>data</a> from its start until the
 <a>end offset</a>.

 <li>Return <var>s</var>.
</ol>

<hr>

Note: The {{createContextualFragment()}}, {{Range/getClientRects()}}, and {{Range/getBoundingClientRect()}} methods
are defined in other specifications.
[[DOM-Parsing]]
[[CSSOM-VIEW]]



<h2 id="traversal">Traversal</h2>

{{NodeIterator}} and {{TreeWalker}} objects can be used
to filter and traverse <a>node</a>
<a>trees</a>.

Each {{NodeIterator}} and {{TreeWalker}} object also
has an associated <dfn id=concept-traversal-root for="traversal">root</dfn>
<a>node</a>,
<dfn id=concept-traversal-whatToShow for="traversal">whatToShow</dfn> bitmask, and
<dfn id=concept-traversal-filter for="traversal">filter</dfn> callback.

To <dfn id=concept-node-filter for="node">filter</dfn> <var>node</var> run
these steps:

<ol>
 <li>Let <var>n</var> be <var>node</var>'s
 {{Node/nodeType}} attribute value minus 1.
 <li>If the <var>n</var><sup>th</sup> bit (where 0 is the least
 significant bit) of
 <a for="traversal">whatToShow</a> is not set,
 return {{NodeFilter/FILTER_SKIP}}.
 <!-- !((1 << (node.nodeType - 1)) & whatToShow) -->
 <li>If <a for="traversal">filter</a> is null,
 return {{NodeFilter/FILTER_ACCEPT}}.
 <li>Let <var>result</var> be the return value of calling
 <a for="traversal">filter</a>'s
 {{NodeFilter/acceptNode()}} with <var>node</var> as
 argument. Rethrow any exceptions.
 <!-- no need to pass callback this value; it's undefined which becomes the global object -->
 <li>Return <var>result</var>.
</ol>


<h3 id="interface-nodeiterator">Interface {{NodeIterator}}</h3>

<pre class=idl>
[Exposed=Window]
interface NodeIterator {
  [SameObject] readonly attribute Node root;
  readonly attribute Node referenceNode;
  readonly attribute boolean pointerBeforeReferenceNode;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;

  Node? nextNode();
  Node? previousNode();

  void detach();
};
</pre>

Note: {{NodeIterator}} objects can be created using the
{{createNodeIterator()}}
method.

Each {{NodeIterator}} object has an associated
<dfn>iterator collection</dfn>, which is a
<a>collection</a> rooted at
<a for="traversal">root</a>, whose filter matches any
<a>node</a>.

Each {{NodeIterator}} object has these
<a>removing steps</a> with <var>oldNode</var>,
<var>oldParent</var>, and <var>oldPreviousSibling</var>:

<ol>
 <li>If <var>oldNode</var> is not an
 <a>inclusive ancestor</a> of the
 {{NodeIterator/referenceNode}} attribute value,
 terminate these steps.

 <li>
  If the
  {{NodeIterator/pointerBeforeReferenceNode}}
  attribute value is true, run these substeps:

  <ol>
   <li>Let <var>nextSibling</var> be <var>oldPreviousSibling</var>'s
   <a>next sibling</a>, if
   <var>oldPreviousSibling</var> is non-null, and <var>oldParent</var>'s
   <a>first child</a> otherwise.

   <li>If <var>nextSibling</var> is non-null, set the
   {{NodeIterator/referenceNode}} attribute to
   <var>nextSibling</var> and terminate these steps.

   <li>Let <var>next</var> be the first <a>node</a>
   <a>following</a> <var>oldParent</var>.

   <li>If <var>next</var> is not an
   <a>inclusive ancestor</a> of
   <a for="traversal">root</a>, set the
   {{NodeIterator/referenceNode}} attribute to
   <var>next</var> and terminate these steps.

   <li>
    Otherwise, set the
    {{NodeIterator/pointerBeforeReferenceNode}}
    attribute to false.

    Note: Steps are not terminated here.
  </ol>

 <li>Set the {{NodeIterator/referenceNode}} attribute
 to first <a>node</a>
 <a>preceding</a> <var>oldPreviousSibling</var>, if
 <var>oldPreviousSibling</var> is non-null, and to <var>oldParent</var> otherwise.
</ol>

Note: As mentioned earlier {{NodeIterator}} objects have an
associated <a for="traversal">root</a>
<a>node</a>,
<a for="traversal">whatToShow</a> bitmask, and
<a for="traversal">filter</a> callback as well.

<hr>

The <dfn attribute for="NodeIterator">root</dfn> attribute
must return <a for="traversal">root</a>.

The
<dfn attribute for="NodeIterator">referenceNode</dfn>
and
<dfn attribute for="NodeIterator">pointerBeforeReferenceNode</dfn>
attributes must return what they were initialized to.

The <dfn attribute for="NodeIterator">whatToShow</dfn>
attribute must return
<a for="traversal">whatToShow</a>.

The <dfn attribute for="NodeIterator">filter</dfn>
attribute must return <a for="traversal">filter</a>.

To <dfn id=concept-NodeIterator-traverse for="NodeIterator">traverse</dfn> in direction
<var>direction</var> run these steps:

<ol>
 <li>Let <var>node</var> be the value of the
 {{NodeIterator/referenceNode}} attribute.

 <li>Let <var>before node</var> be the value of the
 {{NodeIterator/pointerBeforeReferenceNode}}
 attribute.

 <li>
  Run these substeps:
  <ol>
   <li>
    <dl class=switch>
     <dt>If direction is next
     <dd>
      If <var>before node</var> is false, let <var>node</var>
      be the first <a>node</a>
      <a>following</a>
      <var>node</var> in the <span>iterator collection</span>. If
      there is no such <a>node</a> return null.
      If <var>before node</var> is true, set it to false.
     <dt>If direction is previous
     <dd>
      If <var>before node</var> is true, let <var>node</var>
      be the first <a>node</a>
      <a>preceding</a>
      <var>node</var> in the <span>iterator collection</span>. If
      there is no such <a>node</a> return null.
      If <var>before node</var> is false, set it to true.
    </dl>
   <li><a for="node">Filter</a>
   <var>node</var> and let <var>result</var> be the return
   value.
   <li>
    If <var>result</var> is
    {{NodeFilter/FILTER_ACCEPT}}, go to the
    next step in the overall set of steps.
    Otherwise, run these substeps again.
  </ol>
 <li>Set the
 {{NodeIterator/referenceNode}} attribute
 to <var>node</var>, set the
 {{NodeIterator/pointerBeforeReferenceNode}}
 attribute to <var>before node</var>, and return
 <var>node</var>.
</ol>

The <dfn method for="NodeIterator">nextNode()</dfn>
method must <a for="NodeIterator">traverse</a> in
direction next.

The
<dfn method for="NodeIterator">previousNode()</dfn>
method must <a for="NodeIterator">traverse</a> in
direction previous.

The <dfn method for="NodeIterator">detach()</dfn>
method must do nothing. <span class=note>Its functionality (disabling a
{{NodeIterator}} object) was removed, but the method itself is preserved
for compatibility.</span>


<h3 id='interface-treewalker'>Interface {{TreeWalker}}</h3>

<pre class=idl>
[Exposed=Window]
interface TreeWalker {
  [SameObject] readonly attribute Node root;
  readonly attribute unsigned long whatToShow;
  readonly attribute NodeFilter? filter;
           attribute Node currentNode;

  Node? parentNode();
  Node? firstChild();
  Node? lastChild();
  Node? previousSibling();
  Node? nextSibling();
  Node? previousNode();
  Node? nextNode();
};</pre>


Note: {{TreeWalker}} objects can be created using the
{{createTreeWalker()}} method.

Note: As mentioned earlier {{TreeWalker}} objects have an
associated <a for="traversal">root</a>
<a>node</a>,
<a for="traversal">whatToShow</a> bitmask, and
<a for="traversal">filter</a> callback.

The <dfn attribute for="TreeWalker">root</dfn> attribute must
return <a for="traversal">root</a>.

The <dfn attribute for="TreeWalker">whatToShow</dfn>
attribute must return
<a for="traversal">whatToShow</a>.

The <dfn attribute for="TreeWalker">filter</dfn> attribute
must return <a for="traversal">filter</a>.

The <dfn attribute for="TreeWalker">currentNode</dfn>
attribute must return what it was initialized to.

Setting the {{TreeWalker/currentNode}}
attribute must set it to the new value.


The <dfn method for="TreeWalker">parentNode()</dfn>
method must run these steps:

<ol>
 <li>Let <var>node</var> be the value of the
 {{TreeWalker/currentNode}} attribute.

 <li>
  While <var>node</var> is not null and is not
  <a for="traversal">root</a>, run these substeps:

  <ol>
   <li>Let <var>node</var> be <var>node</var>'s
   <a>parent</a>.

   <li>If <var>node</var> is not null and
   <a for="node">filtering</a> <var>node</var>
   returns {{NodeFilter/FILTER_ACCEPT}},
   then set the {{TreeWalker/currentNode}}
   attribute to <var>node</var>, return <var>node</var>.
  </ol>

 <li>Return null.
</ol>

To <dfn id=concept-traverse-children>traverse children</dfn> of type
<var>type</var>, run these steps:

<ol>
 <li>Let <var>node</var> be the value
 of the {{TreeWalker/currentNode}} attribute.

 <li>Set <var>node</var> to <var>node</var>'s
 <a>first child</a> if
 <var>type</var> is first, and <var>node</var>'s
 <a>last child</a> if
 <var>type</var> is last.

 <li>
  <dfn id=concept-traverse-children-main lt="Traverse children main step">Main</dfn>:
  While <var>node</var> is not null, run these substeps:

  <ol>
   <li><a for="node">Filter</a>
   <var>node</var> and let <var>result</var> be the return
   value.

   <li>If <var>result</var> is
   {{NodeFilter/FILTER_ACCEPT}}, then set
   the {{TreeWalker/currentNode}}
   attribute to <var>node</var> and return <var>node</var>.

   <li>
    If <var>result</var> is
    {{NodeFilter/FILTER_SKIP}}, run these
    subsubsteps:

    <ol>
     <li>Let <var>child</var> be <var>node</var>'s
     <a>first child</a> if
     <var>type</var> is first, and <var>node</var>'s
     <a>last child</a> if
     <var>type</var> is last.

     <li>If <var>child</var> is not null, set <var>node</var>
     to <var>child</var> and goto
     <a lt="Traverse children main step">Main</a>.
    </ol>

   <li>
    While <var>node</var> is not null, run these subsubsteps:

    <ol>
     <li>Let <var>sibling</var> be <var>node</var>'s
     <a>next sibling</a> if
     <var>type</var> is first, and <var>node</var>'s
     <a>previous sibling</a> if
     <var>type</var> is last.

     <li>If <var>sibling</var> is not null, set
     <var>node</var> to <var>sibling</var> and goto
     <a lt="Traverse children main step">Main</a>.

     <li>Let <var>parent</var> be <var>node</var>'s
     <a>parent</a>.

     <li>If <var>parent</var> is null, <var>parent</var> is
     <a for="traversal">root</a>, or
     <var>parent</var> is
     {{TreeWalker/currentNode}} attribute's
     value, return null.

     <li>Otherwise, set <var>node</var> to <var>parent</var>.
    </ol>
  </ol>
 <li>Return null.
</ol>

The <dfn method for="TreeWalker">firstChild()</dfn>
method must <a>traverse children</a>
of type first.

The <dfn method for="TreeWalker">lastChild()</dfn>
method must <a>traverse children</a>
of type last.

To <dfn id=concept-traverse-siblings>traverse siblings</dfn> of type
<var>type</var> run these steps:

<ol>
 <li>Let <var>node</var> be the value of the
 {{TreeWalker/currentNode}} attribute.

 <li>If <var>node</var> is
 <a for="traversal">root</a>, return null.

 <li>
  Run these substeps:

  <ol>
   <li>Let <var>sibling</var> be <var>node</var>'s
   <a>next sibling</a> if
   <var>type</var> is next, and <var>node</var>'s
   <a>previous sibling</a> if
   <var>type</var> is previous.

   <li>
    While <var>sibling</var> is not null, run these subsubsteps:

    <ol>
     <li>Set <var>node</var> to <var>sibling</var>.

     <li><a for="node">Filter</a>
     <var>node</var> and let <var>result</var> be the return
     value.

     <li>If <var>result</var> is
     {{NodeFilter/FILTER_ACCEPT}}, then set
     the {{TreeWalker/currentNode}}
     attribute to <var>node</var> and return <var>node</var>.

     <li>Set <var>sibling</var> to <var>node</var>'s
     <a>first child</a> if
     <var>type</var> is next, and <var>node</var>'s
     <a>last child</a> if
     <var>type</var> is previous.

     <li>If <var>result</var> is
     {{NodeFilter/FILTER_REJECT}} or
     <var>sibling</var> is null, then set <var>sibling</var> to
     <var>node</var>'s
     <a>next sibling</a> if
     <var>type</var> is next, and <var>node</var>'s
     <a>previous sibling</a> if
     <var>type</var> is previous.
    </ol>

   <li>Set <var>node</var> to its
   <a>parent</a>.

   <li>If <var>node</var> is null or is
   <a for="traversal">root</a>, return null.

   <li><a for="node">Filter</a>
   <var>node</var> and if the return value is
   {{NodeFilter/FILTER_ACCEPT}}, then
   return null.
   <!-- XXX WTF? -->

   <li>Run these substeps again.
  </ol>
</ol>

The
<dfn method for="TreeWalker">nextSibling()</dfn>
method must <a>traverse siblings</a>
of type next.

The
<dfn method for="TreeWalker">previousSibling()</dfn>
method must <a>traverse siblings</a>
of type previous.

The
<dfn method for="TreeWalker">previousNode()</dfn>
method must run these steps:

<ol>
 <li>Let <var>node</var> be the value of the
 {{TreeWalker/currentNode}} attribute.

 <li>
  While <var>node</var> is not
  <a for="traversal">root</a>, run these substeps:

  <ol>
   <li>Let <var>sibling</var> be the
   <a>previous sibling</a> of
   <var>node</var>.

   <li>
    While <var>sibling</var> is not null, run these subsubsteps:

    <ol>
     <li>Set <var>node</var> to <var>sibling</var>.

     <li><a for="node">Filter</a>
     <var>node</var> and let <var>result</var> be the return
     value.

     <li>While <var>result</var> is not
     {{NodeFilter/FILTER_REJECT}} and
     <var>node</var> has a
     <a>child</a>, set <var>node</var>
     to its <a>last child</a> and then
     <a for="node">filter</a> <var>node</var> and
     set <var>result</var> to the return value.

     <li>If <var>result</var> is
     {{NodeFilter/FILTER_ACCEPT}}, then set
     the {{TreeWalker/currentNode}}
     attribute to <var>node</var> and return <var>node</var>.

     <li>Set <var>sibling</var> to the
     <a>previous sibling</a> of
     <var>node</var>.
    </ol>

   <li>If <var>node</var> is
   <a for="traversal">root</a> or <var>node</var>'s
   <a>parent</a> is null, return null.

   <li>Set <var>node</var> to its
   <a>parent</a>.

   <li><a for="node">Filter</a>
   <var>node</var> and if the return value is
   {{NodeFilter/FILTER_ACCEPT}}, then set
   the {{TreeWalker/currentNode}} attribute
   to <var>node</var> and return <var>node</var>.
  </ol>

 <li>Return null.
</ol>

The <dfn method for="TreeWalker">nextNode()</dfn>
method must run these steps:

<ol>
 <li>Let <var>node</var> be the value of the
 {{TreeWalker/currentNode}} attribute.

 <li>Let <var>result</var> be
 {{NodeFilter/FILTER_ACCEPT}}.

 <li>
  Run these substeps:

  <ol>
   <li>
    While <var>result</var> is not
    {{NodeFilter/FILTER_REJECT}} and
    <var>node</var> has a <a>child</a>,
    run these subsubsteps:

    <ol>
     <li>Set <var>node</var> to its
     <a>first child</a>.

     <li><a for="node">Filter</a>
     <var>node</var> and set <var>result</var> to the return
     value.

     <li>If <var>result</var> is
     {{NodeFilter/FILTER_ACCEPT}}, then set
     the {{TreeWalker/currentNode}} attribute
     to <var>node</var> and return <var>node</var>.
    </ol>

   <li>
    If a <a>node</a> is
    <a>following</a>
    <var>node</var> and is not
    <a>following</a>
    <a for="traversal">root</a>, set
    <var>node</var> to the first such
    <a>node</a>.
    Otherwise, return null.
    <!-- Implemented as iterating over parent/nextSibling -->

   <li><a for="node">Filter</a>
   <var>node</var> and set <var>result</var> to the return
   value.

   <li>If <var>result</var> is
   {{NodeFilter/FILTER_ACCEPT}}, then set
   the {{TreeWalker/currentNode}} attribute
   to <var>node</var> and return <var>node</var>.

   <li>Run these substeps again.
  </ol>
</ol>



<h3 id="interface-nodefilter">Interface {{NodeFilter}}</h3>

<pre class=idl>
[Exposed=Window]
callback interface NodeFilter {
  // Constants for acceptNode()
  const unsigned short FILTER_ACCEPT = 1;
  const unsigned short FILTER_REJECT = 2;
  const unsigned short FILTER_SKIP = 3;

  // Constants for whatToShow
  const unsigned long SHOW_ALL = 0xFFFFFFFF;
  const unsigned long SHOW_ELEMENT = 0x1;
  const unsigned long SHOW_ATTRIBUTE = 0x2; // historical
  const unsigned long SHOW_TEXT = 0x4;
  const unsigned long SHOW_CDATA_SECTION = 0x8; // historical
  const unsigned long SHOW_ENTITY_REFERENCE = 0x10; // historical
  const unsigned long SHOW_ENTITY = 0x20; // historical
  const unsigned long SHOW_PROCESSING_INSTRUCTION = 0x40;
  const unsigned long SHOW_COMMENT = 0x80;
  const unsigned long SHOW_DOCUMENT = 0x100;
  const unsigned long SHOW_DOCUMENT_TYPE = 0x200;
  const unsigned long SHOW_DOCUMENT_FRAGMENT = 0x400;
  const unsigned long SHOW_NOTATION = 0x800; // historical

  unsigned short acceptNode(Node node);
};
</pre>

{{NodeFilter}} objects can be used as
<a for="traversal">filter</a> callback and provide
constants for the <a for="traversal">whatToShow</a>
bitmask.

Note: It is typically implemented as a JavaScript function.

These constants can be used as callback return value:

<ul class="brief">
 <li><dfn const for="NodeFilter">FILTER_ACCEPT</dfn> (1);
 <li><dfn const for="NodeFilter">FILTER_REJECT</dfn> (2);
 <li><dfn const for="NodeFilter">FILTER_SKIP</dfn> (3).
</ul>

These constants can be used for the
<a for="traversal">whatToShow</a> bitmask:

<ul class="brief">
 <li><dfn const for="NodeFilter">SHOW_ALL</dfn> (4294967295, FFFFFFFF in hexadecimal);
 <li><dfn const for="NodeFilter">SHOW_ELEMENT</dfn> (1);
 <!-- AttrExodus
 <li><dfn const for="NodeFilter">SHOW_ATTRIBUTE</dfn> (2, historical);
 -->
 <li><dfn const for="NodeFilter">SHOW_TEXT</dfn> (4);
 <!-- XXX still questionable
 <li><dfn const for="NodeFilter">SHOW_CDATA_SECTION</dfn> (8; historical);
 -->
 <li><dfn const for="NodeFilter">SHOW_PROCESSING_INSTRUCTION</dfn> (64, 40 in hexadecimal);
 <li><dfn const for="NodeFilter">SHOW_COMMENT</dfn> (128, 80 in hexadecimal);
 <li><dfn const for="NodeFilter">SHOW_DOCUMENT</dfn> (256, 100 in hexadecimal);
 <li><dfn const for="NodeFilter">SHOW_DOCUMENT_TYPE</dfn> (512, 200 in hexadecimal);
 <li><dfn const for="NodeFilter">SHOW_DOCUMENT_FRAGMENT</dfn> (1024, 400 in hexadecimal).
</ul>



<h2 id="sets">Sets</h2>

Note: Yes, the names {{DOMTokenList}} and
{{DOMSettableTokenList}} are unfortunate legacy mishaps.

<h3 id="interface-domtokenlist">Interface {{DOMTokenList}}</h3>

<pre class="idl">
interface DOMTokenList {
  readonly attribute unsigned long length;
  getter DOMString? item(unsigned long index);
  boolean contains(DOMString token);
  void add(DOMString... tokens);
  void remove(DOMString... tokens);
  boolean toggle(DOMString token, optional boolean force);
  stringifier;
  iterable&lt;DOMString>;
};
</pre>

A {{DOMTokenList}} object has an associated ordered set of
<dfn id=concept-DTL-tokens for="DomTokenList">tokens</dfn>, which is initially empty.

A {{DOMTokenList}} object also has an associated
<a>element</a> and an
<a>attribute</a>'s
<a for=Attr>local name</a>.

A {{DOMTokenList}} object's
<dfn id=concept-DTL-update for="DOMTokenList">update steps</dfn> are:

<ol>
 <li>If there is no associated
 <a>attribute</a> (when the object is a
 {{DOMSettableTokenList}}), terminate these steps.

 <li><a>Set an attribute value</a>
 for the associated <a>element</a> using
 associated <a>attribute</a>'s
 <a for=Attr>local name</a> and the result
 of running the <a>ordered set serializer</a>
 for <a>tokens</a>.
</ol>

<dl class="domintro">
 <dt><code><var>tokenlist</var> . {{DOMTokenList/length}}</code>
 <dd>Returns the number of tokens.

 <dt><code><var>tokenlist</var> . {{DOMTokenList/item(<var>index</var>)}}</code>
 <dt><code><var>tokenlist</var>[<var>index</var>]</code>
 <dd>Returns the token with index <var>index</var>.

 <dt><code><var>tokenlist</var> . {{DOMTokenList/contains(<var>token</var>)}}</code>
 <dd>
  Returns true if <var>token</var> is present, and false otherwise.
  Throws a {{SyntaxError}} exception if <var>token</var>
  is the empty string.
  Throws an {{InvalidCharacterError}} exception if
  <var>token</var> contains any
  <a>ASCII whitespace</a>.

 <dt><code><var>tokenlist</var> . <a for=DOMTokenList lt="add()">add(<var>tokens</var>&hellip;)</a></code>
 <dd>
  Adds all arguments passed, except those already present.
  Throws a {{SyntaxError}} exception if one if the arguments
  is the empty string.
  Throws an {{InvalidCharacterError}} exception if one of the
  arguments contains any
  <a>ASCII whitespace</a>.

 <dt><code><var>tokenlist</var> . <a for=DOMTokenList lt="remove()">remove(<var>tokens</var>&hellip;)</a></code>
 <dd>
  Removes arguments passed, if they are present.
  Throws a {{SyntaxError}} exception if one if the arguments
  is the empty string.
  Throws an {{InvalidCharacterError}} exception if one of the
  arguments contains any
  <a>ASCII whitespace</a>.

 <dt><code><var>tokenlist</var> . <a method for=DOMTokenList lt="toggle()">toggle(<var>token</var> [, <var>force</var>])</a></code>
 <dd>
  If <var>force</var> is not given, "toggles"
  <var>token</var>, removing it if it's present and adding it if it's
  not. If <var>force</var> is true, adds <var>token</var> (same as {{add()}}).
  If <var>force</var> is false, removes <var>token</var> (same as {{DOMTokenList/remove()}}).
  Returns true if <var>token</var> is now present, and false otherwise.
  Throws a {{SyntaxError}} exception if <var>token</var> is empty.
  Throws an {{InvalidCharacterError}} exception if <var>token</var> contains any spaces.
</dl>

<div class="impl">

The <dfn attribute for=DOMTokenList>length</dfn>
attribute must return the number of tokens in the
<a>tokens</a>.

The object's
<a>supported property indices</a> are the
numbers in the range zero to the number of tokens in
<a>tokens</a> minus one, unless
<a>tokens</a> is  empty, in which case there are no
<a>supported property indices</a>.

The
<dfn method for="DOMTokenList">item(<var>index</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>index</var> is equal to or greater than the number of
 tokens in <a>tokens</a>, return null.

 <li>Return the <var>index</var>th token in
 <a>tokens</a>.
</ol>

The
<dfn method for="DOMTokenList">contains(<var>token</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>token</var> is the empty string, then
 <a>throw</a> a {{SyntaxError}}
 exception.

 <li>If <var>token</var> contains any
 <a>ASCII whitespace</a>, then
 <a>throw</a>
 an {{InvalidCharacterError}} exception.

 <li>Return true if <var>token</var> is in
 <a>tokens</a>, and false otherwise.
</ol>

The
<dfn method for="DOMTokenList" lt="add(tokens)|add()">add(<var>tokens</var>&hellip;)</dfn>
method must run these steps:

<ol>
 <li>If one of <var>tokens</var> is the empty string,
 <a>throw</a> a {{SyntaxError}}
 exception.

 <li>If one of <var>tokens</var> contains any
 <a>ASCII whitespace</a>, then
 <a>throw</a> an
 {{InvalidCharacterError}} exception.

 <li>For each <var>token</var> in <var>tokens</var>, in given
 order, that is not in <a>tokens</a>, append
 <var>token</var> to <a>tokens</a>.

 <li>Run the <a>update steps</a>.
</ol>

The
<dfn method for="DOMTokenList" lt="remove(tokens)|remove()">remove(<var>tokens</var>&hellip;)</dfn>
method must run these steps:

<ol>
 <li>If one of <var>tokens</var> is the empty string,
 <a>throw</a> a {{SyntaxError}}
 exception.

 <li>If one of <var>tokens</var> contains any
 <a>ASCII whitespace</a>, then
 <a>throw</a> an
 {{InvalidCharacterError}} exception.

 <li>For each <var>token</var> in <var>tokens</var>, remove
 <var>token</var> from <a>tokens</a>.

 <li>Run the <a>update steps</a>.
</ol>

The
<dfn method for="DOMTokenList">toggle(<var>token</var>, <var>force</var>)</dfn>
method must run these steps:

<ol>
 <li>If <var>token</var> is the empty string,
 <a>throw</a> a {{SyntaxError}}
 exception.

 <li>If <var>token</var> contains any
 <a>ASCII whitespace</a>,
 <a>throw</a> an
 {{InvalidCharacterError}} exception.

 <li>
  If <var>token</var> is in <a>tokens</a>, run
  these substeps:

  <ol>
   <li>If <var>force</var> is either not passed or is false, then remove
   <var>token</var> from <a>tokens</a>, run the
   <a>update steps</a>, and return false.

   <li>Otherwise, return true.
  </ol>

 <li>
  Otherwise, run these substeps:

  <ol>
   <li>If <var>force</var> is passed and is false, return false.

   <li>Otherwise, append <var>token</var> to
   <a>tokens</a>, run the
   <a>update steps</a>, and return true.
  </ol>
</ol>

The <dfn dfn for="DOMTokenList" lt="stringification behavior">stringifier</dfn> must
return the result of the
<a>ordered set serializer</a> for
<a>tokens</a>.

</div>


<h3 id="interface-domsettabletokenlist">Interface {{DOMSettableTokenList}}</h3>

<pre class="idl">
interface DOMSettableTokenList : DOMTokenList {
            attribute DOMString value;
};
</pre>

A {{DOMSettableTokenList}} object is equivalent to a
{{DOMTokenList}} object without an associated
<a>attribute</a>.

<dl class="domintro">
 <dt><code><var>tokenlist</var> . {{DOMSettableTokenList/value}}</code>
 <dd>
  Returns the associated set as string.
  Can be set, to change the associated set via a string.
</dl>

<div class="impl">

The <dfn attribute for=DOMSettableTokenList>value</dfn>
attribute must return the result of the
<a>ordered set serializer</a> for
<a>tokens</a>.

Setting the {{DOMSettableTokenList/value}}
attribute must run the <a>ordered set parser</a>
for the given value and set <a>tokens</a> to the result.

</div>



<h2 id='historical'>Historical</h2>

As explained in <a href="#goals">goals</a> this specification is a
significant revision of various DOM specifications. This section attempts to
enumerate the changes.


<h3 id='dom-events-changes'>DOM Events</h3>

These are the changes made to the features described in the
"DOM Event Architecture", "Basic Event Interfaces", "Mutation Events", and
"Mutation Name Event Types" chapters of <cite>DOM Level 3 Events</cite>. The
other chapters are defined by the <cite>UI Events</cite> specification.
[[!UIEVENTS]]

<ul class=brief>
 <li>Events have constructors now.
 <li>Removes <dfn interface>MutationEvent</dfn>, and
 <dfn interface>MutationNameEvent</dfn>.
 <li>Fire is no longer synonymous with dispatch, but includes initializing
 an event.
 <li>The propagation and canceled flags are unset when invoking
 {{Event/initEvent()}} rather than after
 dispatch.
</ul>


<h3 id='dom-core-changes'>DOM Core</h3>

These are the changes made to the features described in
<cite>DOM Level 3 Core</cite>.

{{DOMString}}, {{DOMException}}, and
{{DOMTimeStamp}} are now defined in Web IDL.

{{Node}} now inherits from {{EventTarget}}.

<a>Nodes</a> are implicitly
<a>adopted</a> across
<a>document</a> boundaries.

<a>Doctypes</a> now always have a
<a>node document</a> and can be moved
across <a>document</a> boundaries.

{{ProcessingInstruction}} now inherits from
{{CharacterData}}.

<dfn method for="Node">hasAttributes()</dfn> and
<dfn attribute for="Node">attributes</dfn> moved from {{Node}}
to {{Element}}.

<dfn attribute for="Node">namespaceURI</dfn>,
<dfn attribute for="Node">prefix</dfn>, and
<dfn attribute for="Node">localName</dfn> moved from {{Node}} to
{{Element}} and {{Attr}}.

The remainder of interfaces and interface members listed in this section
were removed to simplify the DOM platform. Implementations conforming to
this specification will not support them.

<p class=warning>It is not yet clear if it would be web-compatible to
remove all the following features. The editors welcome any data showing that
some of these features should be reintroduced.

Interfaces:
<ul class=brief dfn-type="interface">
 <li><dfn><code>CDATASection</code></dfn>
 <li><dfn><code>DOMConfiguration</code></dfn>
 <li><dfn><code>DOMError</code></dfn>
 <li><dfn><code>DOMErrorHandler</code></dfn>
 <li><dfn><code>DOMImplementationList</code></dfn>
 <li><dfn><code>DOMImplementationSource</code></dfn>
 <li><dfn><code>DOMLocator</code></dfn>
 <li><dfn><code>DOMObject</code></dfn>
 <li><dfn><code>DOMStringList</code></dfn>
 <li><dfn><code>DOMUserData</code></dfn>
 <li><dfn><code>Entity</code></dfn>
 <li><dfn><code>EntityReference</code></dfn>
 <li><dfn><code>NameList</code></dfn>
 <li><dfn><code>Notation</code></dfn>
 <li><dfn><code>TypeInfo</code></dfn>
 <li><dfn><code>UserDataHandler</code></dfn>
</ul>

Interface members:
<dl>
 <dt>{{Node}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for="Node">isSupported</dfn>
   <li><dfn method for="Node">getFeature()</dfn>
   <li><dfn method for="Node">getUserData()</dfn>
   <li><dfn method for="Node">setUserData()</dfn>

   <li><dfn method for="Node">isSameNode()</dfn>
  </ul>

 <dt>{{Document}}
 <dd>
  <ul class=brief>
   <li><dfn method for="Document">createCDATASection()</dfn>
   <li><dfn method for="Document">createEntityReference()</dfn>
   <li><dfn attribute for="Document">xmlEncoding</dfn>
   <li><dfn attribute for="Document">xmlStandalone</dfn>
   <li><dfn attribute for="Document">xmlVersion</dfn>
   <li><dfn attribute for="Document">strictErrorChecking</dfn>
   <li><dfn attribute for="Document">domConfig</dfn>
   <li><dfn method for="Document">normalizeDocument()</dfn>
   <li><dfn method for="Document">renameNode()</dfn>
  </ul>

 <dt>{{DOMImplementation}}
 <dd>
  <ul class=brief>
   <li><dfn method for="DOMImplementation">getFeature()</dfn>
  </ul>

 <dt>{{Attr}}
 <dd>
  No longer inherits from {{Node}} and therefore completely
  changed.
  <!--AttrExodus
  <dfn attribute for="Attr">schemaTypeInfo</dfn>
  <dfn attribute for="Attr">isId</dfn>
  -->

 <dt>{{Element}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for="Element">schemaTypeInfo</dfn>
   <li><dfn method for="Element">setIdAttribute()</dfn>
   <li><dfn method for="Element">setIdAttributeNS()</dfn>
   <li><dfn method for="Element">setIdAttributeNode()</dfn>
  </ul>

 <dt>{{DocumentType}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for="DocumentType">entities</dfn>
   <li><dfn attribute for="DocumentType">notations</dfn>
   <li><dfn attribute for="DocumentType">internalSubset</dfn>
  </ul>

 <dt>{{Text}}
 <dd>
  <ul class=brief>
   <li><dfn attribute for="Text">isElementContentWhitespace</dfn>
   <li><dfn method for="Text">replaceWholeText()</dfn>
  </ul>
</dl>

<h3 id='dom-ranges-changes'>DOM Ranges</h3>

These are the changes made to the features described in the
"Document Object Model Range" chapter of
<cite>DOM Level 2 Traversal and Range</cite>.

<ul>
 <li><dfn interface>RangeException</dfn> has been removed.

 <li>{{Range}} objects can now be moved between
 <a>documents</a> and used on
 <a>nodes</a> that are not <a>in a document</a>.

 <li>A wild {{Range/Range()}} constructor appeared.

 <li>New methods {{Range/comparePoint()}},
 {{Range/intersectsNode()}}, and
 {{Range/isPointInRange()}} have been added.

 <li>{{Range/detach()}} is now a no-op.

 <li><dfn method for="Range">toString()</dfn> is now defined through
 IDL.
</ul>


<h3 id='dom-traversal-changes'>DOM Traversal</h3>

These are the changes made to the features described in the
"Document Object Model Traversal" chapter of
<cite>DOM Level 2 Traversal and Range</cite>.

<ul>
 <li>{{createNodeIterator()}} and
 {{createTreeWalker()}} now have optional
 arguments and lack a fourth argument which is no longer relevant given entity references
 never made it into the DOM.

 <li>The <dfn for="NodeIterator, TreeWalker" attribute>expandEntityReferences</dfn> attribute has been removed from the
 {{NodeIterator}} and {{TreeWalker}} interfaces for the aforementioned
 reason.

 <li>The {{NodeIterator/referenceNode}} and
 {{NodeIterator/pointerBeforeReferenceNode}}
 attributes have been added to {{NodeIterator}} objects to align with proprietary
 extensions of implementations.

 <li>{{NodeIterator/nextNode()}} and
 {{NodeIterator/previousNode()}} now throw
 when invoked from a {{NodeFilter}} to align with user agents.

 <li>{{NodeIterator/detach()}} is now a no-op.
</ul>


<h2 class=no-num id="acks">Acknowledgments</h2>

There have been a lot of people that have helped make DOM more interoperable over the
years and thereby furthered the goals of this standard. Likewise many people have helped
making this standard what it is today.

With that, many thanks to
Adam Klein,
Adrian Bateman,
Alex Russell,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Björn Höhrmann,
Boris Zbarsky,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
Cameron McCormack,
Christophe Dumez,
Daniel Glazman,
David Bruant,
David Flanagan,
David Håsäther,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Erik Arvidsson,
Gavin Nicol,
Geoffrey Sneddon,
Glen Huang,
Glenn Maynard,
Harald Alvestrand,
Henri Sivonen,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald<!-- technically B.J. Archibald -->,
Jake Verbaten,
James Graham,
James Greene,
James Robinson,
Jens Lindström,
João Eiras,
Joe Kesselman,
Jonas Sicking,
Jonathan Robie,
Joshua Bell,
Justin Summerlin,
呂康豪 (Kang-Hao Lu),
Kevin Sweeney,
Lachlan Hunt,
Lauren Wood,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Mats Palmgren,
Mounir Lamouri,
Michael™ Smith,
Mike Champion,
Ojan Vafai,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Rafael Weinstein,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Rune <span title=Fabulous>F.</span> Halvorsen,
Ryosuke Niwa,
Seo Sanghyeon,
Shiki Okasaka,
Simon Pieters,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Timo Tijhof,
Tom Pixley,
Travis Leithead,
Vidur Apparao,
Warren He,
Yehuda Katz,
Yoichi Osato, and
Zack Weinberg
for being awesome!

This standard is written by
<a lang=nl href=//annevankesteren.nl/>Anne van Kesteren</a>
(<a href=//www.mozilla.org/>Mozilla</a>,
<a href=mailto:annevk@annevk.nl>annevk@annevk.nl</a>) with substantial contributions from
Aryeh Gregor (<a href="//www.mozilla.org/">Mozilla</a>,
<a href=mailto:ayg@aryeh.name>ayg@aryeh.name</a>)
and Ms2ger (<a href="//www.mozilla.org/">Mozilla</a>,
<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).

Per <a rel="license" href="//creativecommons.org/publicdomain/zero/1.0/">CC0</a>, to
the extent possible under law, the editors have waived all copyright and related or
neighboring rights to this work.

<script id=head src=//resources.whatwg.org/dfn.js></script>
<!-- vim: set expandtab shiftwidth=1 tabstop=1 textwidth=76 -->
